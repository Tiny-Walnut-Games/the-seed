"""
Warbler Autonomous Loop: Continuous Narrative Generation Engine

The heartbeat of the simulation. Every tick, generates narrative independently
of player input, spawning NPCs, making decisions, aging entities, and driving
the realm forward. This is what makes the simulation "breathe."

Architecture:
- Runs every N ticks (configurable)
- Queries Warbler: "What happens next in this realm?"
- Parses narrative into structured events (entity lifecycle, NPC behaviors)
- Injects events into event store
- Tracks generated entities and their lifecycles
- Proves fractal scaling without bloat

Data Flow:
  Tick Engine → Autonomous Loop → Warbler Query → Narrative Parse → Events → Event Store → Clients
"""

import asyncio
import json
import uuid
import logging
from dataclasses import dataclass, field
from typing import Dict, List, Any, Optional, Tuple
from datetime import datetime, timezone
from enum import Enum


logger = logging.getLogger(__name__)


class EntityEventType(Enum):
    """Types of entity lifecycle events generated by Warbler."""
    ENTITY_SPAWN = "entity_spawn"           # New NPC/creature born into realm
    ENTITY_DESPAWN = "entity_despawn"       # Entity leaves/dies
    ENTITY_ACTION = "entity_action"         # Action taken by entity (move, speak, etc)
    ENTITY_STATE_CHANGE = "entity_state_change"  # Internal state update (aging, mood, etc)
    NPC_DIALOGUE = "npc_dialogue"           # NPC generates dialogue (narrative, not player-directed)
    NPC_DECISION = "npc_decision"           # NPC makes a decision (next destination, quest, etc)
    ENVIRONMENT_CHANGE = "environment_change"    # Realm weather, time, atmosphere shift
    FACTION_EVENT = "faction_event"         # Faction-level narrative event
    QUEST_GENERATED = "quest_generated"     # New procedural quest created
    LORE_EVENT = "lore_event"              # World-building event (discovery, history, etc)


@dataclass
class EntityLifecycle:
    """Tracks a single generated entity's lifecycle."""
    entity_id: str
    entity_type: str              # "npc", "creature", "faction", "landmark"
    realm_id: str
    spawn_tick: int
    spawn_narrative: str          # How entity came into being
    current_state: Dict[str, Any] # Current NPC state (location, mood, quest, etc)
    age_ticks: int = 0           # How many ticks since spawned
    actions_taken: List[str] = field(default_factory=list)  # Recent actions
    is_active: bool = True
    despawn_reason: Optional[str] = None
    despawn_tick: Optional[int] = None


@dataclass
class RealmNarrativeState:
    """State of narrative generation for a specific realm."""
    realm_id: str
    tick_count: int = 0
    entities_spawned_lifetime: int = 0
    entities_active: int = 0
    narrative_density: float = 0.0  # Events per tick (target: 3-5)
    mood: str = "neutral"           # Current realm atmosphere
    active_entities: Dict[str, EntityLifecycle] = field(default_factory=dict)
    event_history: List[Dict[str, Any]] = field(default_factory=list)


class WarblerNarrativeParser:
    """
    Parses Warbler narrative output into structured events.
    
    Warbler returns unstructured narrative like:
        "In the bustling merchant quarter, Kayla the spice trader arranges her wares..."
        "Two hooded figures meet in the tavern and exchange whispered secrets."
        "The merchant Thorne sets out toward the northern pass to find rare silks."
    
    Parser extracts:
        - Entity spawns/despawns
        - NPC decisions and actions
        - Environmental changes
        - Quest hooks
    """
    
    def __init__(self):
        self.known_entities: Dict[str, EntityLifecycle] = {}
    
    def parse_narrative(
        self,
        narrative: str,
        realm_id: str,
        current_tick: int
    ) -> List[Dict[str, Any]]:
        """
        Parse narrative text into structured events.
        
        Args:
            narrative: Raw narrative from Warbler
            realm_id: Which realm this narrative is for
            current_tick: Current simulation tick
        
        Returns:
            List of structured events ready for event store
        """
        events = []
        
        # Simple heuristic parsing (can be enhanced with NLP/regex)
        # Look for common narrative patterns
        
        lines = narrative.split("\n")
        for line in lines:
            if not line.strip():
                continue
            
            # Pattern 1: Entity introduction (spawn)
            # "Kayla the spice trader" / "The hooded figure"
            if self._is_entity_intro(line):
                entity = self._extract_entity_spawn(line, realm_id, current_tick)
                if entity:
                    events.append(entity)
            
            # Pattern 2: Action/dialogue
            # "arranges her wares" / "whispered secrets"
            elif self._is_entity_action(line):
                action = self._extract_entity_action(line, realm_id, current_tick)
                if action:
                    events.append(action)
            
            # Pattern 3: Movement/destination
            # "sets out toward the northern pass"
            elif self._is_entity_movement(line):
                movement = self._extract_entity_movement(line, realm_id, current_tick)
                if movement:
                    events.append(movement)
            
            # Pattern 4: Environmental
            # "The sun rises" / "A storm approaches"
            elif self._is_environment_change(line):
                env = self._extract_environment_change(line, realm_id, current_tick)
                if env:
                    events.append(env)
        
        return events
    
    def _is_entity_intro(self, line: str) -> bool:
        """Check if line introduces a new entity."""
        keywords = ["the ", " enters ", " appears ", " arrives ", " born ", " spawned "]
        lower = line.lower()
        # More specific: must have both "the" and an action verb OR explicit intro verb
        has_explicit_intro = any(kw in lower for kw in [" enters ", " appears ", " arrives "])
        return has_explicit_intro or ("the " in lower and any(t in lower for t in ["merchant", "trader", "guard", "scholar"]))
    
    def _is_entity_action(self, line: str) -> bool:
        """Check if line describes an entity action."""
        keywords = [" speaks ", " says ", " does ", " takes ", " performs ", 
                    " arranges ", " exchanges ", " meets ", " confronts "]
        return any(kw in line.lower() for kw in keywords)
    
    def _is_entity_movement(self, line: str) -> bool:
        """Check if line indicates movement."""
        keywords = [" toward ", " to the ", " journeys ", " travels ", " heads ", 
                    "sets out", " moves ", " departs ", " goes ", " leaves "]
        lower = line.lower()
        return any(kw in lower for kw in keywords)
    
    def _is_environment_change(self, line: str) -> bool:
        """Check if line indicates environmental change."""
        keywords = ["the sun ", " weather ", " storm ", " wind ", " fog ", 
                    " rain ", " night ", " morning ", " dusk "]
        return any(kw in line.lower() for kw in keywords)
    
    def _extract_entity_spawn(
        self,
        line: str,
        realm_id: str,
        current_tick: int
    ) -> Optional[Dict[str, Any]]:
        """Extract entity spawn event."""
        entity_id = f"{realm_id}_entity_{uuid.uuid4().hex[:8]}"
        
        # Try to extract entity name from narrative
        entity_name = self._extract_name(line)
        entity_type = self._infer_entity_type(line)
        
        return {
            "event_type": EntityEventType.ENTITY_SPAWN.value,
            "entity_id": entity_id,
            "entity_name": entity_name,
            "entity_type": entity_type,
            "realm_id": realm_id,
            "tick": current_tick,
            "narrative": line,
            "initial_location": self._extract_location(line),
            "timestamp": datetime.now(timezone.utc).isoformat(),
        }
    
    def _extract_entity_action(
        self,
        line: str,
        realm_id: str,
        current_tick: int
    ) -> Optional[Dict[str, Any]]:
        """Extract entity action event."""
        return {
            "event_type": EntityEventType.ENTITY_ACTION.value,
            "realm_id": realm_id,
            "tick": current_tick,
            "narrative": line,
            "timestamp": datetime.now(timezone.utc).isoformat(),
        }
    
    def _extract_entity_movement(
        self,
        line: str,
        realm_id: str,
        current_tick: int
    ) -> Optional[Dict[str, Any]]:
        """Extract entity movement event."""
        destination = self._extract_location(line)
        
        return {
            "event_type": EntityEventType.NPC_DECISION.value,
            "realm_id": realm_id,
            "tick": current_tick,
            "decision_type": "travel",
            "destination": destination,
            "narrative": line,
            "timestamp": datetime.now(timezone.utc).isoformat(),
        }
    
    def _extract_environment_change(
        self,
        line: str,
        realm_id: str,
        current_tick: int
    ) -> Optional[Dict[str, Any]]:
        """Extract environment change event."""
        return {
            "event_type": EntityEventType.ENVIRONMENT_CHANGE.value,
            "realm_id": realm_id,
            "tick": current_tick,
            "narrative": line,
            "timestamp": datetime.now(timezone.utc).isoformat(),
        }
    
    def _extract_name(self, text: str) -> str:
        """Extract entity name from narrative."""
        # Simple heuristic: capitalized words followed by title
        # "Kayla the spice trader" -> "Kayla"
        words = text.split()
        if words and words[0][0].isupper():
            return words[0]
        return "Unknown"
    
    def _infer_entity_type(self, text: str) -> str:
        """Infer entity type from narrative."""
        lower = text.lower()
        if "merchant" in lower or "trader" in lower:
            return "npc_merchant"
        elif "guard" in lower or "soldier" in lower:
            return "npc_guard"
        elif "scholar" in lower or "sage" in lower:
            return "npc_scholar"
        elif "creature" in lower or "beast" in lower:
            return "creature"
        else:
            return "npc"
    
    def _extract_location(self, text: str) -> str:
        """Extract location reference from narrative."""
        keywords = {
            "quarter": "merchant_quarter",
            "tavern": "tavern",
            "pass": "mountain_pass",
            "forest": "forest",
            "village": "village",
            "castle": "castle",
        }
        
        lower = text.lower()
        for keyword, location in keywords.items():
            if keyword in lower:
                return location
        
        return "unknown"


class WarblerAutonomousLoop:
    """
    Continuous narrative generation loop.
    
    Runs every tick (or every N ticks) to:
    1. Query Warbler for realm narrative
    2. Parse narrative into structured events
    3. Inject events into event store
    4. Track entity lifecycles
    5. Prove scaling properties
    """
    
    def __init__(
        self,
        event_store,
        warbler_query_service,
        tick_interval_ticks: int = 1,  # Run every tick
    ):
        """
        Initialize autonomous loop.
        
        Args:
            event_store: EventStore instance for persisting events
            warbler_query_service: WarblerQueryService for narrative generation
            tick_interval_ticks: How often to generate narrative (1 = every tick)
        """
        self.event_store = event_store
        self.warbler_query_service = warbler_query_service
        self.tick_interval_ticks = tick_interval_ticks
        
        self.parser = WarblerNarrativeParser()
        self.realm_states: Dict[str, RealmNarrativeState] = {}
        self.is_running = False
    
    async def initialize_realm(self, realm_id: str):
        """Initialize narrative state for a realm."""
        if realm_id not in self.realm_states:
            self.realm_states[realm_id] = RealmNarrativeState(realm_id=realm_id)
            logger.info(f"Initialized autonomous narrative for realm: {realm_id}")
    
    async def execute_autonomous_tick(
        self,
        realm_id: str,
        current_tick: int,
        realm_state: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Execute one autonomous narrative generation cycle.
        
        Args:
            realm_id: Which realm to generate narrative for
            current_tick: Current simulation tick number
            realm_state: Optional current state of realm (for context)
        
        Returns:
            Summary of generated events and entities
        """
        # Ensure realm state exists
        await self.initialize_realm(realm_id)
        
        realm_narrative = self.realm_states[realm_id]
        
        # Query Warbler for narrative (3-5 events this tick)
        narrative = await self._query_warbler_narrative(
            realm_id,
            realm_narrative,
            current_tick
        )
        
        if not narrative:
            return {
                "realm_id": realm_id,
                "tick": current_tick,
                "events_generated": 0,
                "status": "no_narrative",
            }
        
        # Parse narrative into structured events
        events = self.parser.parse_narrative(narrative, realm_id, current_tick)
        
        # Inject events into event store
        injected_events = await self._inject_events(realm_id, events)
        
        # Update realm narrative state
        realm_narrative.tick_count += 1
        realm_narrative.event_history.extend(injected_events)
        realm_narrative.narrative_density = len(injected_events)
        
        logger.info(
            f"[Autonomous] Realm {realm_id} tick {current_tick}: "
            f"Generated {len(injected_events)} events"
        )
        
        return {
            "realm_id": realm_id,
            "tick": current_tick,
            "events_generated": len(injected_events),
            "events": injected_events,
            "entities_active": len(realm_narrative.active_entities),
            "status": "success",
        }
    
    async def _query_warbler_narrative(
        self,
        realm_id: str,
        realm_state: RealmNarrativeState,
        current_tick: int
    ) -> Optional[str]:
        """
        Query Warbler for next narrative segment.
        
        This is the key interface to Warbler for autonomous generation.
        """
        try:
            # Build context from realm state
            context = {
                "realm_id": realm_id,
                "current_tick": current_tick,
                "active_entities": len(realm_state.active_entities),
                "mood": realm_state.mood,
                "narrative_request": self._build_narrative_prompt(realm_state),
            }
            
            # Query Warbler (should return unstructured narrative)
            # For now, return a mock narrative - integrate with real Warbler later
            narrative = await self._generate_or_query_narrative(context)
            
            return narrative
        
        except Exception as e:
            logger.error(f"Error querying Warbler for {realm_id}: {e}")
            return None
    
    async def _generate_or_query_narrative(self, context: Dict[str, Any]) -> str:
        """
        Generate or query narrative. 
        
        Uses real Warbler query service if available, otherwise falls back to procedural generation.
        """
        # Try to use warbler_query_service if available
        if self.warbler_query_service:
            try:
                narrative = await self.warbler_query_service.query_narrative(context)
                return narrative
            except Exception as e:
                logger.warning(f"Failed to query Warbler service: {e}, falling back to procedural generation")
        
        # Fallback: generate procedural narrative
        import random
        
        templates = [
            "In the {location}, {npc1} the {type1} arranges their wares for the day. A customer approaches looking for exotic goods.",
            "Two hooded figures meet near the {location} and exchange whispered secrets about a lost artifact.",
            "{npc1} the {type1} sets out toward the {destination} hoping to find rare materials for their craft.",
            "The atmosphere shifts in the {location}. Dark clouds gather overhead as a storm approaches.",
            "A wandering {type1} named {npc1} arrives in the {location}, seeking work and fortune.",
        ]
        
        locations = ["merchant quarter", "tavern", "marketplace", "forest edge", "mountain pass"]
        npcs = ["Kayla", "Thorne", "Elara", "Marcus", "Soren"]
        types = ["merchant", "scholar", "guard", "wanderer", "knight"]
        destinations = ["northern pass", "hidden grove", "distant city", "ancient ruins"]
        
        template = random.choice(templates)
        narrative = template.format(
            location=random.choice(locations),
            npc1=random.choice(npcs),
            npc2=random.choice(npcs),
            type1=random.choice(types),
            type2=random.choice(types),
            destination=random.choice(destinations),
        )
        
        return narrative
    
    def _build_narrative_prompt(self, realm_state: RealmNarrativeState) -> str:
        """Build prompt for Warbler narrative generation."""
        return (
            f"Generate 3-5 narrative events for a realm with {realm_state.entities_active} active entities. "
            f"Current mood: {realm_state.mood}. "
            f"Include NPC decisions, discoveries, and world events. "
            f"Keep narrative immersive and procedurally varied."
        )
    
    async def _inject_events(
        self,
        realm_id: str,
        events: List[Dict[str, Any]]
    ) -> List[Dict[str, Any]]:
        """
        Inject generated events into event store.
        
        Each event becomes a permanent part of the realm's narrative history.
        """
        injected = []
        
        for event in events:
            try:
                # Determine stream based on event type
                if event["event_type"] == EntityEventType.ENTITY_SPAWN.value:
                    stream_id = f"stat7/{realm_id}/entities/{event['entity_id']}"
                else:
                    stream_id = f"stat7/{realm_id}/events"
                
                # Append to event store
                stored_event = self.event_store.append_event(
                    stream_id=stream_id,
                    event_type=event["event_type"],
                    payload=event,
                    metadata={
                        "source": "warbler_autonomous_loop",
                        "realm_id": realm_id,
                    }
                )
                
                injected.append(stored_event)
                
                # Update entity tracking if spawn
                if event["event_type"] == EntityEventType.ENTITY_SPAWN.value:
                    lifecycle = EntityLifecycle(
                        entity_id=event["entity_id"],
                        entity_type=event["entity_type"],
                        realm_id=realm_id,
                        spawn_tick=event["tick"],
                        spawn_narrative=event["narrative"],
                        current_state={
                            "location": event.get("initial_location", "unknown"),
                            "status": "active",
                        }
                    )
                    self.realm_states[realm_id].active_entities[event["entity_id"]] = lifecycle
                    self.realm_states[realm_id].entities_spawned_lifetime += 1
                    self.realm_states[realm_id].entities_active += 1
            
            except Exception as e:
                logger.error(f"Error injecting event to event store: {e}")
        
        return injected
    
    def get_realm_narrative_stats(self, realm_id: str) -> Dict[str, Any]:
        """Get stats about narrative generation for a realm."""
        if realm_id not in self.realm_states:
            return {"error": "Realm not initialized"}
        
        state = self.realm_states[realm_id]
        return {
            "realm_id": realm_id,
            "ticks_run": state.tick_count,
            "entities_spawned_lifetime": state.entities_spawned_lifetime,
            "entities_active": state.entities_active,
            "narrative_density": state.narrative_density,
            "mood": state.mood,
            "total_events_generated": len(state.event_history),
        }
    
    async def shutdown(self):
        """Graceful shutdown of autonomous loop."""
        self.is_running = False
        logger.info("Warbler Autonomous Loop shutdown complete")