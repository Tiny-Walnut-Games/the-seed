name: Chronicle Keeper - TLDL Scribe System

on:
  issues:
    types: [opened, closed, edited]
  issue_comment:
    types: [created]
  pull_request:
    types: [opened, closed, synchronize]
  workflow_dispatch:
  workflow_run:
    workflows: ["Living Dev Agent CI"]
    types: [completed]
  schedule:
    # Daily at 6 AM UTC to ensure fresh ledger for the day
    - cron: '0 6 * * *'

jobs:
  # ğŸ§™â€â™‚ï¸ Explain when Chronicle Keeper is dormant (runs when the main job is skipped)
  chronicle-keeper-skip-explain:
    runs-on: ubuntu-latest
    name: Chronicle Keeper - Why the Scribe Slumbers
    # Only run when Chronicle Keeper would be skipped
    if: >
      !((github.event_name == 'issues' && (contains(github.event.issue.title, 'ğŸ§ ') || contains(github.event.issue.title, 'ğŸ§ ğŸ“œ') || contains(github.event.issue.title, 'ğŸ’¸'))) ||
      (github.event_name == 'issue_comment' && (contains(github.event.comment.body, 'TLDL:') || contains(github.event.comment.body, 'ğŸ“œ') || contains(github.event.comment.body, 'chronicle') || contains(github.event.comment.body, 'lore') || contains(github.event.comment.body, 'ğŸ’¸'))) ||
      (github.event_name == 'pull_request' && github.event.action == 'closed' && github.event.pull_request.merged == true) ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion != 'success') ||
      (github.event_name == 'workflow_dispatch') ||
      (github.event_name == 'schedule'))
    
    steps:
      - name: ğŸ›¡ï¸ Chronicle Keeper Dormancy Explanation
        run: |
          echo "ğŸ“œ CHRONICLE KEEPER STATUS: DORMANT"
          echo ""
          echo "ğŸ§™â€â™‚ï¸ The Chronicle Keeper slumbers, preserving the cheeks from spam."
          echo "âš¡ This mystical scribe only awakens for truly lore-worthy events:"
          echo ""
          echo "ğŸ§  Brain Emoji Issues: '${{ github.event_name }}' â‰  issues with ğŸ§ "
          echo "ğŸ’¸ XP Refactoring Issues: '${{ github.event_name }}' â‰  issues with ğŸ’¸"
          echo "ğŸ’¬ Lore Comments: No sacred keywords detected (TLDL:, ğŸ“œ, chronicle, lore, ğŸ’¸)" 
          echo "ğŸ”€ Merged PRs: '${{ github.event_name }}' â‰  merged pull_request"
          echo "ğŸ’¥ Failed Workflows: '${{ github.event_name }}' â‰  failed workflow_run"
          echo ""
          echo "ğŸ¯ Current Event: ${{ github.event_name }}"
          echo "ğŸ“‹ Action: ${{ github.event.action || 'N/A' }}"
          echo ""
          echo "âœ¨ The scribe awaits worthy tales to chronicle."
          echo "ğŸ™Œ All hail the Cheeks! This skip prevents notification spam."

  # ğŸ“œ Parse and generate TLDL entries for lore-worthy content 
  chronicle-keeper:
    runs-on: ubuntu-latest
    name: Chronicle Keeper - Preserve the Lore
    # Run for lore-worthy events or manual dispatch
    if: >
      (github.event_name == 'issues' && (contains(github.event.issue.title, 'ğŸ§ ') || contains(github.event.issue.title, 'ğŸ§ ğŸ“œ') || contains(github.event.issue.title, 'ğŸ’¸'))) ||
      (github.event_name == 'issue_comment' && (contains(github.event.comment.body, 'TLDL:') || contains(github.event.comment.body, 'ğŸ“œ') || contains(github.event.comment.body, 'chronicle') || contains(github.event.comment.body, 'lore') || contains(github.event.comment.body, 'ğŸ’¸'))) ||
      (github.event_name == 'pull_request' && github.event.action == 'closed' && github.event.pull_request.merged == true) ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion != 'success') ||
      (github.event_name == 'workflow_dispatch') ||
      (github.event_name == 'schedule')
    
    steps:
      - name: ğŸ§™â€â™‚ï¸ Summon the Repository
        uses: actions/checkout@v5
        with:
          # Need write access to create TLDL entries
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: ğŸ Prepare the Scrolls (Setup Python)
        uses: actions/setup-python@v5.6.0
        with:
          python-version: '3.11'

      - name: ğŸŸ¢ Prepare the Chronicles (Setup Node.js)
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: ğŸ“¦ Gather Dependencies  
        run: |
          # Python dependencies for ScrollQuoteEngine
          python -m pip install --upgrade pip
          pip install PyYAML argparse || echo "âš ï¸ Some dependencies may already be available"
          
          # ğŸ”’ Node.js dependencies with pinned versions (addresses issue #50)
          npm install js-yaml@^4.1.0 || { echo "âš ï¸ js-yaml installation failed: $?"; echo "âš ï¸ js-yaml installation attempted"; }
          
          # ğŸ”’ Install pinned @playwright/mcp version (addresses issue #50)
          if [ -f "package.json" ]; then
            npm install || echo "âš ï¸ Package installation issues detected"
          fi
          
          # ğŸ•’ Add startup buffer for MCP connection stability (addresses issue #50)
          echo "ğŸ•’ Adding startup buffer for MCP server stability..."
          sleep 2

      - name: ğŸ• Chronicle Keeper Cooldown Check
        id: cooldown_check
        if: github.event_name == 'issue_comment'
        run: |
          echo "ğŸ• Checking Chronicle Keeper cooldown protection..."
          
          ISSUE_NUMBER="${{ github.event.issue.number }}"
          COMMENT_BODY="${{ github.event.comment.body }}"
          EVENT_NAME="${{ github.event_name }}"
          
          # Check cooldown to prevent loops
          cd scripts/chronicle-keeper
          
          COOLDOWN_EXIT_CODE=0
          node cooldown-check.js --issue="$ISSUE_NUMBER" --event="$EVENT_NAME" --comment="$COMMENT_BODY" || COOLDOWN_EXIT_CODE=$?
          
          if [ $COOLDOWN_EXIT_CODE -eq 42 ]; then
            echo "cooldown_active=true" >> $GITHUB_OUTPUT
            echo "ğŸš« Chronicle Keeper in cooldown, skipping execution to prevent loops"
          elif [ $COOLDOWN_EXIT_CODE -eq 0 ]; then
            echo "cooldown_active=false" >> $GITHUB_OUTPUT
            echo "âœ… No cooldown active, proceeding with Chronicle Keeper"
          else
            echo "cooldown_active=false" >> $GITHUB_OUTPUT
            echo "âš ï¸ Cooldown check had issues but proceeding (exit code: $COOLDOWN_EXIT_CODE)"
          fi

      - name: ğŸ” Chronicle Keeper Analysis
        id: parse-content
        if: steps.cooldown_check.outputs.cooldown_active != 'true'
        run: |
          set -Eeuo pipefail
          trap 'echo "ğŸ’¥ Script failure near line $LINENO"' ERR

          echo "ğŸ§  Chronicle Keeper awakening..."
          echo "Event: ${{ github.event_name }}"
          echo "Action: ${{ github.event.action }}"
          
          # ğŸ·ï¸ Centralized function for generating labels JSON
          generate_labels_json() {
            case "$1" in
              "github_event")
                # Transform GitHub event labels to standard format
                echo "$2" | jq '[.[] | {name: .name}]'
                ;;
              "manual_dispatch")
                # Static labels for manual dispatch
                jq -n '[{name:"brain-dump"},{name:"manual-dispatch"}]'
                ;;
              "fallback")
                # Static labels for fallback scenarios
                jq -n '[{name:"fallback"}]'
                ;;
              *)
                echo "âŒ Unknown label type: $1" >&2
                return 1
                ;;
            esac
          }
          
          PARSE_RESULT="null"
          
          if [[ "${{ github.event_name }}" == "issues" ]]; then
            echo "ğŸ“‹ Parsing issue #${{ github.event.issue.number }}"

            ISSUE_NUMBER=${{ github.event.issue.number }}
            ISSUE_TITLE_JSON='${{ toJson(github.event.issue.title) }}'
            ISSUE_BODY_JSON='${{ toJson(github.event.issue.body) }}'
            ISSUE_USER_LOGIN_JSON='${{ toJson(github.event.issue.user.login) }}'
            ISSUE_CREATED_AT_JSON='${{ toJson(github.event.issue.created_at) }}'
            ISSUE_UPDATED_AT_JSON='${{ toJson(github.event.issue.updated_at) }}'
            ISSUE_STATE_JSON='${{ toJson(github.event.issue.state) }}'
            ISSUE_HTML_URL_JSON='${{ toJson(github.event.issue.html_url) }}'
            
            # Write labels JSON to temp file to avoid shell syntax issues with multiline JSON
            echo '${{ toJson(github.event.issue.labels) }}' > /tmp/labels.json
            LABELS_JSON=$(generate_labels_json "github_event" "$(cat /tmp/labels.json)")

            jq -n --argjson number "$ISSUE_NUMBER" --argjson title "$ISSUE_TITLE_JSON" --argjson body "$ISSUE_BODY_JSON" --argjson user_login "$ISSUE_USER_LOGIN_JSON" --argjson created_at "$ISSUE_CREATED_AT_JSON" --argjson updated_at "$ISSUE_UPDATED_AT_JSON" --argjson state "$ISSUE_STATE_JSON" --argjson labels "$LABELS_JSON" --argjson html_url "$ISSUE_HTML_URL_JSON" '{ number: $number, title: $title, body: $body, user: {login: $user_login}, created_at: $created_at, updated_at: $updated_at, state: $state, labels: $labels, html_url: $html_url }' > /tmp/github-content.json

            PARSE_RESULT="issue"
          fi
          
          if [[ "${{ github.event_name }}" == "issue_comment" ]]; then
            echo "ğŸ’¬ Parsing comment on issue #${{ github.event.issue.number }}"

            COMMENT_ID=${{ github.event.comment.id }}
            COMMENT_BODY_JSON='${{ toJson(github.event.comment.body) }}'
            COMMENT_USER_LOGIN_JSON='${{ toJson(github.event.comment.user.login) }}'
            COMMENT_CREATED_AT_JSON='${{ toJson(github.event.comment.created_at) }}'
            COMMENT_UPDATED_AT_JSON='${{ toJson(github.event.comment.updated_at) }}'
            COMMENT_HTML_URL_JSON='${{ toJson(github.event.comment.html_url) }}'
            ISSUE_URL_JSON='${{ toJson(github.event.issue.url) }}'

            jq -n --argjson id "$COMMENT_ID" --argjson body "$COMMENT_BODY_JSON" --argjson user_login "$COMMENT_USER_LOGIN_JSON" --argjson created_at "$COMMENT_CREATED_AT_JSON" --argjson updated_at "$COMMENT_UPDATED_AT_JSON" --argjson html_url "$COMMENT_HTML_URL_JSON" --argjson issue_url "$ISSUE_URL_JSON" '{ id: $id, body: $body, user: {login: $user_login}, created_at: $created_at, updated_at: $updated_at, html_url: $html_url, issue_url: $issue_url }' > /tmp/github-content.json

            PARSE_RESULT="comment"
          fi
          
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "ğŸ”€ Parsing pull request #${{ github.event.pull_request.number }}"

            PR_NUMBER=${{ github.event.pull_request.number }}
            PR_TITLE_JSON='${{ toJson(github.event.pull_request.title) }}'
            PR_BODY_JSON='${{ toJson(github.event.pull_request.body) }}'
            PR_USER_LOGIN_JSON='${{ toJson(github.event.pull_request.user.login) }}'
            PR_CREATED_AT_JSON='${{ toJson(github.event.pull_request.created_at) }}'
            PR_UPDATED_AT_JSON='${{ toJson(github.event.pull_request.updated_at) }}'
            PR_MERGED_AT_JSON='${{ toJson(github.event.pull_request.merged_at) }}'
            PR_STATE_JSON='${{ toJson(github.event.pull_request.state) }}'
            PR_MERGED_JSON='${{ toJson(github.event.pull_request.merged) }}'
            PR_BASE_REF_JSON='${{ toJson(github.event.pull_request.base.ref) }}'
            PR_HEAD_REF_JSON='${{ toJson(github.event.pull_request.head.ref) }}'
            PR_HTML_URL_JSON='${{ toJson(github.event.pull_request.html_url) }}'
            PR_COMMITS=${{ github.event.pull_request.commits }}
            PR_ADDITIONS=${{ github.event.pull_request.additions }}
            PR_DELETIONS=${{ github.event.pull_request.deletions }}
            PR_CHANGED_FILES=${{ github.event.pull_request.changed_files }}
            
            # Write labels JSON to temp file to avoid shell syntax issues with multiline JSON
            echo '${{ toJson(github.event.pull_request.labels) }}' > /tmp/pr-labels.json
            LABELS_JSON=$(generate_labels_json "github_event" "$(cat /tmp/pr-labels.json)")

            echo '${{ toJson(github.event.pull_request.body) }}' > /tmp/pr-body.json
            PR_BODY_JSON=$(cat /tmp/pr-body.json)

            PARSE_RESULT="pull_request"
          fi
          
          if [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            echo "âš™ï¸ Parsing workflow run"

            WR_ID=${{ github.event.workflow_run.id }}
            WR_NAME_JSON='${{ toJson(github.event.workflow_run.name) }}'
            WR_STATUS_JSON='${{ toJson(github.event.workflow_run.status) }}'
            WR_CONCLUSION_JSON='${{ toJson(github.event.workflow_run.conclusion) }}'
            WR_CREATED_AT_JSON='${{ toJson(github.event.workflow_run.created_at) }}'
            WR_UPDATED_AT_JSON='${{ toJson(github.event.workflow_run.updated_at) }}'
            WR_HEAD_BRANCH_JSON='${{ toJson(github.event.workflow_run.head_branch) }}'
            WR_HEAD_SHA_JSON='${{ toJson(github.event.workflow_run.head_sha) }}'
            WR_HTML_URL_JSON='${{ toJson(github.event.workflow_run.html_url) }}'
            WR_RUN_NUMBER=${{ github.event.workflow_run.run_number }}

            jq -n --argjson id "$WR_ID" --argjson name "$WR_NAME_JSON" --argjson status "$WR_STATUS_JSON" --argjson conclusion "$WR_CONCLUSION_JSON" --argjson created_at "$WR_CREATED_AT_JSON" --argjson updated_at "$WR_UPDATED_AT_JSON" --argjson head_branch "$WR_HEAD_BRANCH_JSON" --argjson head_sha "$WR_HEAD_SHA_JSON" --argjson html_url "$WR_HTML_URL_JSON" --argjson run_number "$WR_RUN_NUMBER" '{ id: $id, name: $name, status: $status, conclusion: $conclusion, created_at: $created_at, updated_at: $updated_at, head_branch: $head_branch, head_sha: $head_sha, html_url: $html_url, run_number: $run_number }' > /tmp/github-content.json

            PARSE_RESULT="workflow_run"
          fi
          
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "ğŸ§  Manual dispatch detected - creating brain dump entry"

            echo "ğŸ“‹ Full GitHub event payload:"
            cat "$GITHUB_EVENT_PATH" | jq . > /tmp/github-event.json || echo "{}" > /tmp/github-event.json
            cat /tmp/github-event.json

            MANUAL_DISPATCH_ID="MD$(date +%s)"
            NOW_TS="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
            TITLE_TEXT="Manual Chronicle Keeper Invocation"
            BODY_TEXT="Manual dispatch test entry"
            MD_HTML_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            LABELS_JSON=$(generate_labels_json "manual_dispatch")


            jq -n --arg type "manual_dispatch" --arg number "$MANUAL_DISPATCH_ID" --arg title "$TITLE_TEXT" --arg body "$BODY_TEXT" --arg user_login "chronicle-keeper" --arg created_at "$NOW_TS" --arg updated_at "$NOW_TS" --arg state "manual" --arg html_url "$MD_HTML_URL" --argjson labels "$LABELS_JSON" '{ type: $type, number: $number, title: $title, body: $body, user: {login: $user_login}, created_at: $created_at, updated_at: $updated_at, state: $state, labels: $labels, html_url: $html_url }' > /tmp/github-content.json


            jq -n --arg type "manual_dispatch" --arg number "$MANUAL_DISPATCH_ID" --arg title "$TITLE_TEXT" --arg body "$BODY_TEXT" --arg user_login "chronicle-keeper" --arg created_at "$NOW_TS" --arg updated_at "$NOW_TS" --arg state "manual" --arg html_url "$MD_HTML_URL" --argjson labels '[{"name":"brain-dump"},{"name":"manual-dispatch"}]' '{ type: $type, number: $number, title: $title, body: $body, user: {login: $user_login}, created_at: $created_at, updated_at: $updated_at, state: $state, labels: $labels, html_url: $html_url }' > /tmp/github-content.json
            PARSE_RESULT="brain_dump"
          fi
          
          if [[ "${{ github.event_name }}" == "schedule" ]]; then
            echo "â° Scheduled daily ledger generation detected"

            echo "ğŸ“‹ Full GitHub event payload:"
            cat "$GITHUB_EVENT_PATH" | jq . > /tmp/github-event.json || echo "{}" > /tmp/github-event.json
            cat /tmp/github-event.json

            SCHEDULE_ID="SCH$(date +%s)"
            NOW_TS="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
            TITLE_TEXT="Daily Chronicle Keeper - Scheduled Ledger Generation"
            BODY_TEXT="Scheduled daily ledger entry for $(date +%Y-%m-%d)"
            LABELS_JSON=$(generate_labels_json "manual_dispatch")
            
            SCH_HTML_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

            jq -n --arg type "scheduled_ledger" --arg number "$SCHEDULE_ID" --arg title "$TITLE_TEXT" --arg body "$BODY_TEXT" --arg user_login "chronicle-keeper" --arg created_at "$NOW_TS" --arg updated_at "$NOW_TS" --arg state "scheduled" --arg html_url "$SCH_HTML_URL" --argjson labels '[{"name":"daily-ledger"},{"name":"scheduled"}]' '{ type: $type, number: $number, title: $title, body: $body, user: {login: $user_login}, created_at: $created_at, updated_at: $updated_at, state: $state, labels: $labels, html_url: $html_url }' > /tmp/github-content.json
            PARSE_RESULT="scheduled_ledger"
          fi
          
            echo "âš ï¸ No specific event matched. Defaulting to 'brain_dump'."

            FALLBACK_ID="FB$(date +%s)"
            NOW_TS="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
            TITLE_TEXT="Chronicle Keeper Fallback Entry"
            BODY_TEXT="Fallback entry"
            LABELS_JSON=$(generate_labels_json "fallback")

            FB_HTML_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

            jq -n --arg type "fallback" --arg number "$FALLBACK_ID" --arg title "$TITLE_TEXT" --arg body "$BODY_TEXT" --arg user_login "chronicle-keeper" --arg created_at "$NOW_TS" --arg updated_at "$NOW_TS" --arg state "fallback" --arg html_url "$FB_HTML_URL" --argjson labels "$LABELS_JSON" '{ type: $type, number: $number, title: $title, body: $body, user: {login: $user_login}, created_at: $created_at, updated_at: $updated_at, state: $state, labels: $labels, html_url: $html_url }' > /tmp/github-content.json

            PARSE_RESULT="brain_dump"
          fi

          echo "content-type=$PARSE_RESULT" >> "$GITHUB_OUTPUT"
          echo "ğŸ“‹ Content to parse:"
          cat /tmp/github-content.json | jq .

      - name: ğŸ§ª Chronicle Keeper Parsing
        id: scribe-parse
        if: steps.parse-content.outputs.content-type != 'null' && steps.cooldown_check.outputs.cooldown_active != 'true'
        run: |
          # Test the scribe parser with actual content
          echo "ğŸ” Running Chronicle Keeper parser..."
          
          cd scripts/chronicle-keeper
          
          # Create a test script to use our JSON content
          cat > test-parse.js <<'EOF'
          const fs = require('fs');
          const ScribeParser = require('./scribe-parser.js');
          
          try {
            const contentData = JSON.parse(fs.readFileSync('/tmp/github-content.json', 'utf8'));
            const parser = new ScribeParser();
          
            let result;
            if (contentData.number && !contentData.pull_request && !contentData.base) {
              // Issue
              result = parser.parseIssue(contentData);
            } else if (contentData.number && contentData.base) {
              // Pull Request  
              result = parser.parsePullRequest(contentData);
            } else if (contentData.issue_url) {
              // Comment
              result = parser.parseComment(contentData);
            } else if (contentData.workflow_id !== undefined || contentData.name) {
              // Workflow run
              result = parser.parseWorkflowRun(contentData);
            } else if (contentData.type === 'manual_dispatch' || contentData.type === 'fallback' || contentData.type === 'scheduled_ledger') {
              // Manual dispatch, fallback, or scheduled ledger - treat as special issue
              console.log('ğŸ§  Processing manual dispatch/fallback/scheduled content');
              result = parser.parseIssue(contentData);
              // Use the new forceAsLoreWorthy method to properly increment stats
              if (result) {
                result = parser.forceAsLoreWorthy(result);
              }
            }
          
            if (result && result.lore_worthy) {
              console.log('âœ… Content is lore-worthy!');
              console.log('ğŸ“Š Parse stats:', JSON.stringify(parser.getStats()));
          
              // Write result for next step
              fs.writeFileSync('/tmp/parsed-content.json', JSON.stringify(result, null, 2));
              process.exit(0);
            } else if (result && result.rff_message) {
              console.log('ğŸ“‹ Content rejected - RFF Protocol activated');
              console.log('ğŸ“Š Parse stats:', JSON.stringify(parser.getStats()));
              
              // Write RFF message for posting
              fs.writeFileSync('/tmp/rff-message.json', JSON.stringify(result.rff_message, null, 2));
              
              // Signal that RFF should be posted instead of TLDL generation
              process.exit(79); // RFF required
            } else {
              console.log('â„¹ï¸ Content not lore-worthy, skipping TLDL generation');
              process.exit(78); // Skip remaining steps
            }
          } catch (error) {
            console.error('âŒ Parsing error:', error.message);
            process.exit(1);
          }
          EOF
          
          # Run the parser          
          PARSER_EXIT_CODE=0
          node test-parse.js || PARSER_EXIT_CODE=$?
          
          if [ $PARSER_EXIT_CODE -eq 0 ]; then
            echo "parse-success=true" >> $GITHUB_OUTPUT
            echo "rff-required=false" >> $GITHUB_OUTPUT
          elif [ $PARSER_EXIT_CODE -eq 79 ]; then
            echo "parse-success=false" >> $GITHUB_OUTPUT
            echo "rff-required=true" >> $GITHUB_OUTPUT
            echo "ğŸ“‹ RFF Protocol activated - content needs formatting guidance"
          else
            echo "parse-success=false" >> $GITHUB_OUTPUT
            echo "rff-required=false" >> $GITHUB_OUTPUT
          fi

      - name: ğŸ“‹ Post RFF Message
        id: post-rff
        if: steps.scribe-parse.outputs.rff-required == 'true' && steps.cooldown_check.outputs.cooldown_active != 'true'
        run: |
          echo "ğŸ“‹ Posting Request-for-Format message..."
          
          # Read the RFF message
          if [[ -f /tmp/rff-message.json ]]; then
            cat /tmp/rff-message.json | jq .
            
            # For now, just log the RFF message
            # In a full implementation, this would post as a comment or create an issue
            echo "ğŸ§™â€â™‚ï¸ RFF Protocol Message Generated:"
            echo "$(cat /tmp/rff-message.json | jq -r '.resubmissionPrompt')"
            echo ""
            echo "ğŸ“œ Keeper Quote:"
            echo "$(cat /tmp/rff-message.json | jq -r '.keeperQuote')"
            
            # Save RFF for potential artifact upload
            echo "rff-posted=true" >> $GITHUB_OUTPUT
          else
            echo "âŒ No RFF message found"
            echo "rff-posted=false" >> $GITHUB_OUTPUT
          fi

      - name: ğŸ“œ Generate TLDL Scroll
        id: generate-scroll
        if: steps.scribe-parse.outputs.parse-success == 'true' && steps.cooldown_check.outputs.cooldown_active != 'true'
        run: |
          echo "ğŸ“œ Generating TLDL scroll..."
          
          cd scripts/chronicle-keeper
          
          # Create scroll generation script
          cat > generate-scroll.js <<'EOF'
          const fs = require('fs');
          const ScrollGenerator = require('./scroll-generator.js');
          
          try {
            const parsedContent = JSON.parse(fs.readFileSync('/tmp/parsed-content.json', 'utf8'));
            const generator = new ScrollGenerator();
          
            const scroll = generator.generateScrollEntry(parsedContent);
          
            console.log('ğŸ“œ Generated scroll:', scroll.filename);
          
            // Write scroll data for the writer (properly escaped)
            const scrollData = {
              filename: scroll.filename,
              content: scroll.content,
              metadata: scroll.metadata
            };
            fs.writeFileSync('/tmp/scroll-entry.json', JSON.stringify(scrollData, null, 2));
          
            console.log('ğŸ“Š Generation stats:', JSON.stringify(generator.getStats()));
          } catch (error) {
            console.error('âŒ Scroll generation error:', error.message);
            process.exit(1);
          }
          EOF
          
          node generate-scroll.js
          
          echo "scroll-generated=true" >> $GITHUB_OUTPUT

      - name: ğŸ§ ğŸ“œ Generate Capsule Scroll (Archive Wall Detection)
        id: generate-capsule-scroll
        if: steps.generate-scroll.outputs.scroll-generated == 'true' && contains(github.event.issue.title, 'ğŸ§ ğŸ“œ') && steps.cooldown_check.outputs.cooldown_active != 'true'
        run: |
          echo "ğŸ§ ğŸ“œ Archive Wall detected! Generating Capsule Scroll..."
          
          cd scripts/chronicle-keeper
          
          # Create capsule scroll generation script
          cat > generate-capsule-scroll.js <<'EOF'
          const fs = require('fs');
          const CapsuleScrollGenerator = require('./capsule-scroll-generator.js');
          
          try {
            const parsedContent = JSON.parse(fs.readFileSync('/tmp/parsed-content.json', 'utf8'));
            const generator = new CapsuleScrollGenerator();
          
            const result = generator.generateCapsuleScroll(parsedContent);
          
            if (result.success) {
              console.log('ğŸ§ ğŸ“œ Generated Capsule Scroll:', result.filename);
              console.log('ğŸ“Š Capsule stats:', JSON.stringify(result.stats));
              
              // Write result data for potential linking to TLDL
              const capsuleData = {
                filename: result.filename,
                scrollType: result.scrollType,
                success: true,
                stats: result.stats
              };
              fs.writeFileSync('/tmp/capsule-result.json', JSON.stringify(capsuleData, null, 2));
              
            } else {
              console.error('âŒ Capsule Scroll generation failed:', result.error);
              process.exit(1);
            }
          } catch (error) {
            console.error('âŒ Capsule Scroll generation error:', error.message);
            process.exit(1);
          (async () => {
            try {
              const parsedContent = JSON.parse(fs.readFileSync('/tmp/parsed-content.json', 'utf8'));
              const generator = new CapsuleScrollGenerator();
              const result = await generator.generateCapsuleScroll(parsedContent);
          
              if (result.success) {
                console.log('ğŸ§ ğŸ“œ Generated Capsule Scroll:', result.filename);
                console.log('ğŸ“Š Capsule stats:', JSON.stringify(result.stats));
                
                // Write result data for potential linking to TLDL
                const capsuleData = {
                  filename: result.filename,
                  scrollType: result.scrollType,
                  success: true,
                  stats: result.stats
                };
                fs.writeFileSync('/tmp/capsule-result.json', JSON.stringify(capsuleData, null, 2));
                
              } else {
                console.error('âŒ Capsule Scroll generation failed:', result.error);
                process.exit(1);
              }
            } catch (error) {
              console.error('âŒ Capsule Scroll generation error:', error.message);
              process.exit(1);
            }
          })();
          EOF
          
          node generate-capsule-scroll.js
          
          echo "capsule-generated=true" >> $GITHUB_OUTPUT

      - name: âœï¸ Write TLDL Entry
        if: steps.generate-scroll.outputs.scroll-generated == 'true' && steps.cooldown_check.outputs.cooldown_active != 'true'
        run: |
          echo "âœï¸ Writing TLDL entry to chronicle..."
          
          # Use the TLDL writer to save the entry
          ./scripts/chronicle-keeper/tldl-writer.sh write /tmp/scroll-entry.json --verbose
          
          echo "ğŸ“Š Chronicle statistics:"
          ./scripts/chronicle-keeper/tldl-writer.sh stats || true

      # ğŸ§  Daily Ledger Generator â€” Keeperâ€‘plus Ritual
      # Generates a new ledger from /docs/daily-ledger/_TEMPLATE.md
      # Purpose: Preserve daily arc context, decisions, and glyphs for continuity.
      # Usage: Fill each section before day's end. Use Reâ€‘entry Spell to reload tone/context in new thread.
      # Links: Backward/forward to previous/next ledger to maintain unbroken chain.
      - name: ğŸ““ Generate Daily Ledger Entry
        id: generate-daily-ledger
        if: steps.generate-scroll.outputs.scroll-generated == 'true' && steps.cooldown_check.outputs.cooldown_active != 'true'
        run: |
          echo "ğŸ““ Generating Daily Ledger entry..."
          
          # Parse the TLDL content to extract arc information
          if [[ -f /tmp/parsed-content.json ]]; then
            # Try to extract meaningful arc name from the content
            ARC_NAME=""
            
            # Check if it's from an issue with ğŸ§  
            if [[ "${{ github.event_name }}" == "issues" && "${{ contains(github.event.issue.title, 'ğŸ§ ') }}" == "true" ]]; then
              # Extract arc name from issue title, removing ğŸ§  and cleaning up
              ARC_NAME=$(echo '${{ github.event.issue.title }}' | sed 's/ğŸ§ //g' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | cut -c1-50)
              echo "ğŸ“‹ Extracted arc from issue: $ARC_NAME"
            elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
              # Extract arc name from PR title
              ARC_NAME=$(echo '${{ github.event.pull_request.title }}' | cut -c1-50)
              echo "ğŸ”€ Extracted arc from PR: $ARC_NAME"
            elif [[ "${{ github.event_name }}" == "issue_comment" ]]; then
              # Use a generic name for comments
              ARC_NAME="Lore Commentary Arc"
              echo "ğŸ’¬ Using generic arc for comment"
            elif [[ "${{ github.event_name }}" == "schedule" ]]; then
              # For scheduled events, use a daily development arc
              ARC_NAME="Daily Development Arc"
              echo "â° Using scheduled daily arc"
            else
              # Fallback to daily development arc
              ARC_NAME="Chronicle Keeper Arc"
              echo "ğŸ“œ Using default Chronicle Keeper arc"
            fi
            
            # Ensure we have some arc name
            if [[ -z "$ARC_NAME" ]]; then
              ARC_NAME="Daily Development Arc"
            fi
            
            echo "ğŸ¯ Final arc name: $ARC_NAME"
            
            # Generate today's ledger entry (will check if it already exists)
            chmod +x scripts/chronicle-keeper/daily-ledger-generator.sh
            if scripts/chronicle-keeper/daily-ledger-generator.sh today "$ARC_NAME" --verbose; then
              echo "ledger-generated=true" >> $GITHUB_OUTPUT
              log_success "Daily Ledger entry generated successfully"
            else
              echo "ledger-generated=false" >> $GITHUB_OUTPUT
              echo "â„¹ï¸ Daily Ledger entry may already exist for today"
            fi
          else
            echo "âš ï¸ No parsed content available, skipping Daily Ledger generation"
            echo "ledger-generated=false" >> $GITHUB_OUTPUT
          fi

      # Special Daily Ledger generation for scheduled events (runs even without TLDL)
      - name: ğŸ““ Scheduled Daily Ledger Generation
        id: scheduled-daily-ledger
        if: github.event_name == 'schedule'
        run: |
          echo "â° Scheduled Daily Ledger generation..."
          
          ARC_NAME="Daily Development Arc"
          
          # Try to determine what kind of arc we're in based on recent activity
          # Look at recent commits, issues, or PRs to infer current development focus
          if command -v gh >/dev/null 2>&1; then
            # Try to get recent activity context if gh CLI is available
            echo "ğŸ” Attempting to infer current development arc from recent activity..."
            
            # Get most recent merged PR or issue
            RECENT_CONTEXT=$(gh pr list --state merged --limit 1 --json title --jq '.[0].title' 2>/dev/null || \
                           gh issue list --state open --limit 1 --json title --jq '.[0].title' 2>/dev/null || \
                           echo "")
                           
            if [[ -n "$RECENT_CONTEXT" && "$RECENT_CONTEXT" != "null" ]]; then
              ARC_NAME=$(echo "$RECENT_CONTEXT" | cut -c1-50)
              echo "ğŸ“ˆ Inferred arc from recent activity: $ARC_NAME"
            fi
          fi
          
          echo "ğŸ¯ Using arc name: $ARC_NAME"
          
          # Generate today's ledger entry (will use --force to ensure creation for scheduled runs)
          chmod +x scripts/chronicle-keeper/daily-ledger-generator.sh
          if scripts/chronicle-keeper/daily-ledger-generator.sh today "$ARC_NAME" --verbose || \
             scripts/chronicle-keeper/daily-ledger-generator.sh today "$ARC_NAME" --force --verbose; then
            echo "scheduled-ledger-generated=true" >> $GITHUB_OUTPUT
            echo "âœ… Scheduled Daily Ledger entry generated or updated"
          else
            echo "scheduled-ledger-generated=false" >> $GITHUB_OUTPUT
          OUTPUT=$(scripts/chronicle-keeper/daily-ledger-generator.sh today "$ARC_NAME" --verbose 2>&1)
          EXIT_CODE=$?
          if [ $EXIT_CODE -eq 0 ]; then
            echo "scheduled-ledger-generated=true" >> $GITHUB_OUTPUT
            echo "âœ… Scheduled Daily Ledger entry generated or updated"
          elif echo "$OUTPUT" | grep -qi "already exists"; then
            # Only retry with --force if the error is about file existence
            if scripts/chronicle-keeper/daily-ledger-generator.sh today "$ARC_NAME" --force --verbose; then
              echo "scheduled-ledger-generated=true" >> $GITHUB_OUTPUT
              echo "âœ… Scheduled Daily Ledger entry generated or updated (forced)"
            else
              echo "scheduled-ledger-generated=false" >> $GITHUB_OUTPUT
              echo "âŒ Failed to generate scheduled Daily Ledger entry (even with --force)"
            fi
          else
            echo "scheduled-ledger-generated=false" >> $GITHUB_OUTPUT
            echo "âŒ Failed to generate scheduled Daily Ledger entry"
            echo "$OUTPUT"
          fi

      - name: ğŸ›¡ï¸ Validate TLDL Chronicle
        if: steps.generate-scroll.outputs.scroll-generated == 'true' && steps.cooldown_check.outputs.cooldown_active != 'true'
        run: |
          echo "ğŸ›¡ï¸ Validating TLDL chronicle..."
          
          # Run TLDL validation
          ./scripts/chronicle-keeper/tldl-writer.sh validate --verbose || echo "âš ï¸ TLDL validation issues detected"
          
          # Run existing validation if available
          if [[ -f src/SymbolicLinter/validate_docs.py ]]; then
            python3 src/SymbolicLinter/validate_docs.py --tldl-path TLDL/ || echo "âš ï¸ Some validation issues detected"
          fi
          
          # ğŸ”’ Validate MCP configuration for security compliance (addresses issue #50)
          if [[ -f scripts/validate_mcp_config.py ]]; then
            echo "ğŸ”’ Validating MCP security configuration..."
            python3 scripts/validate_mcp_config.py || echo "âš ï¸ MCP configuration issues detected"
          fi

      - name: ğŸ’¸ Faculty Standards Auto-Refactoring Analysis
        id: refactoring-analysis  
        if: steps.generate-scroll.outputs.scroll-generated == 'true' && steps.cooldown_check.outputs.cooldown_active != 'true'
        run: |
          echo "ğŸ’¸ Analyzing generated TLDL for Faculty standards compliance..."
          
          # Find the most recently generated TLDL file
          LATEST_TLDL=$(find TLDL/entries/ -name "*.md" -type f -printf '%T@ %p\n' | sort -n | tail -1 | cut -d' ' -f2- || echo "")
          
          if [[ -n "$LATEST_TLDL" && -f "$LATEST_TLDL" ]]; then
            echo "ğŸ“‹ Analyzing: $LATEST_TLDL"
            
            # Run Faculty Standards analysis
            if [[ -f scripts/chronicle-keeper/auto-refactoring.py ]]; then
              echo "ğŸ” Running Faculty Standards analysis..."
              
              # Use Chronicle Keeper as the developer for auto-generated content
              ANALYSIS_OUTPUT="/tmp/refactoring-analysis.json"
              
              python3 scripts/chronicle-keeper/auto-refactoring.py \
                --analyze "$LATEST_TLDL" \
                --developer "chronicle-keeper" \
                --output "$ANALYSIS_OUTPUT" || echo "âš ï¸ Faculty analysis encountered issues"
              
              if [[ -f "$ANALYSIS_OUTPUT" ]]; then
                # Extract key metrics from analysis
                TOTAL_ISSUES=$(jq -r '.total_issues // 0' "$ANALYSIS_OUTPUT")
                TOTAL_COST=$(jq -r '.total_cost // 0' "$ANALYSIS_OUTPUT")
                AFFORDABLE=$(jq -r '.affordable // false' "$ANALYSIS_OUTPUT")
                
                echo "ğŸ“Š Faculty Standards Analysis Results:"
                echo "  Issues found: $TOTAL_ISSUES"
                echo "  Total refactoring cost: $TOTAL_COST XP"
                echo "  Auto-refactoring affordable: $AFFORDABLE"
                
                # Set outputs for potential auto-refactoring
                echo "analysis-available=true" >> $GITHUB_OUTPUT
                echo "issues-found=$TOTAL_ISSUES" >> $GITHUB_OUTPUT
                echo "refactoring-cost=$TOTAL_COST" >> $GITHUB_OUTPUT
                echo "affordable=$AFFORDABLE" >> $GITHUB_OUTPUT
                echo "analyzed-file=$LATEST_TLDL" >> $GITHUB_OUTPUT
                
                # Create refactoring recommendation comment content
                if [[ $TOTAL_ISSUES -gt 0 ]]; then
                  echo "ğŸ§™â€â™‚ï¸ **Faculty Standards Refactoring Available**" > /tmp/refactoring-comment.md
                  echo "" >> /tmp/refactoring-comment.md
                  echo "ğŸ“œ *\"Every refactor is a gamble: clarity gained, XP drained.\"* â€” **Faculty Doctrine, Vol. VII**" >> /tmp/refactoring-comment.md
                  echo "" >> /tmp/refactoring-comment.md
                  echo "**Analysis Results for \`$(basename "$LATEST_TLDL")\`:**" >> /tmp/refactoring-comment.md
                  echo "- Issues detected: **$TOTAL_ISSUES**" >> /tmp/refactoring-comment.md
                  echo "- Refactoring cost: **$TOTAL_COST XP**" >> /tmp/refactoring-comment.md
                  echo "- Auto-refactoring: **$( [[ "$AFFORDABLE" == "true" ]] && echo "âœ… Affordable" || echo "âŒ Exceeds budget" )**" >> /tmp/refactoring-comment.md
                  echo "" >> /tmp/refactoring-comment.md
                  
                  if [[ "$AFFORDABLE" == "true" && $TOTAL_COST -le 100 ]]; then
                    echo "ğŸ’¡ **Recommendation**: Low-cost fixes detected! Consider automatic refactoring:" >> /tmp/refactoring-comment.md
                    echo "\`\`\`bash" >> /tmp/refactoring-comment.md
                    echo "./scripts/chronicle-keeper/refactor-docs fix \"$LATEST_TLDL\" YourDeveloperName affordable" >> /tmp/refactoring-comment.md
                    echo "\`\`\`" >> /tmp/refactoring-comment.md
                  elif [[ $TOTAL_COST -le 300 ]]; then
                    echo "âš ï¸ **Recommendation**: Moderate refactoring cost - strategic timing recommended:" >> /tmp/refactoring-comment.md
                    echo "\`\`\`bash" >> /tmp/refactoring-comment.md
                    echo "./scripts/chronicle-keeper/refactor-docs analyze \"$LATEST_TLDL\" YourDeveloperName" >> /tmp/refactoring-comment.md
                    echo "\`\`\`" >> /tmp/refactoring-comment.md
                  else
                    echo "ğŸš¨ **Recommendation**: High-cost refactoring detected - consider Faculty intervention:" >> /tmp/refactoring-comment.md
                    echo "\`\`\`bash" >> /tmp/refactoring-comment.md
                    echo "./scripts/chronicle-keeper/refactor-docs emergency \"$LATEST_TLDL\" YourDeveloperName comprehensive" >> /tmp/refactoring-comment.md
                    echo "\`\`\`" >> /tmp/refactoring-comment.md
                  fi
                  
                  echo "" >> /tmp/refactoring-comment.md
                  echo "ğŸ“– **Learn more**: [Costly Automatic Doc Refactoring Guide](docs/costly-automatic-refactoring.md)" >> /tmp/refactoring-comment.md
                  echo "" >> /tmp/refactoring-comment.md
                  echo "*This analysis was performed automatically by the Chronicle Keeper Faculty Standards system.*" >> /tmp/refactoring-comment.md
                  
                  echo "refactoring-comment-ready=true" >> $GITHUB_OUTPUT
                else
                  echo "âœ… Faculty standards compliant - no refactoring needed!"
                  echo "refactoring-comment-ready=false" >> $GITHUB_OUTPUT
                fi
              else
                echo "âš ï¸ Faculty analysis output not available"
                echo "analysis-available=false" >> $GITHUB_OUTPUT
              fi
            else
              echo "âš ï¸ Faculty Standards auto-refactoring system not available"
              echo "analysis-available=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "â„¹ï¸ No recent TLDL file found for Faculty analysis"
            echo "analysis-available=false" >> $GITHUB_OUTPUT
          fi

      - name: ğŸ“¦ Upload Generated TLDL as Artifact
        if: steps.generate-scroll.outputs.scroll-generated == 'true' && steps.cooldown_check.outputs.cooldown_active != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: chronicle-keeper-tldl-entry
          path: |
            TLDL/entries/*.md
            TLDL/index.md
            docs/daily-ledger/*.md
            /tmp/scroll-entry.json
          retention-days: 30

      - name: ğŸ“‹ Upload RFF Message as Artifact
        if: steps.post-rff.outputs.rff-posted == 'true' && steps.cooldown_check.outputs.cooldown_active != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: chronicle-keeper-rff-message
          path: |
            /tmp/rff-message.json
          retention-days: 7

      - name: ğŸ’¸ Upload Faculty Standards Analysis
        if: steps.refactoring-analysis.outputs.analysis-available == 'true' && steps.cooldown_check.outputs.cooldown_active != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: faculty-standards-analysis
          path: |
            /tmp/refactoring-analysis.json
            /tmp/refactoring-comment.md
          retention-days: 30

      - name: ğŸ“¤ Commit TLDL Chronicle
        if: (steps.generate-scroll.outputs.scroll-generated == 'true' || steps.scheduled-daily-ledger.outputs.scheduled-ledger-generated == 'true') && steps.cooldown_check.outputs.cooldown_active != 'true'
        uses: stefanzweifel/git-auto-commit-action@v6
        with:
          commit_message: "ğŸ“œ Chronicle Keeper: Auto-generated TLDL entry and Daily Ledger"
          commit_author: "Chronicle Keeper <chronicle-keeper@living-dev-agent.local>"
          file_pattern: "TLDL/** docs/daily-ledger/**"
          skip_dirty_check: false

      - name: ğŸ§ ğŸ“œ Commit Capsule Scroll
        if: steps.generate-capsule-scroll.outputs.capsule-generated == 'true' && steps.cooldown_check.outputs.cooldown_active != 'true'
        uses: stefanzweifel/git-auto-commit-action@v6
        with:
          commit_message: "ğŸ§ ğŸ“œ Archive Wall Capsule: Auto-generated context preservation scroll"
          commit_author: "Chronicle Keeper <chronicle-keeper@living-dev-agent.local>"
          file_pattern: "capsules/**"
          skip_dirty_check: false

      - name: ğŸ‰ Chronicle Complete
        if: (steps.generate-scroll.outputs.scroll-generated == 'true' || steps.scheduled-daily-ledger.outputs.scheduled-ledger-generated == 'true') && steps.cooldown_check.outputs.cooldown_active != 'true'
        run: |
          if [[ "${{ steps.generate-scroll.outputs.scroll-generated }}" == "true" ]]; then
            echo "ğŸ‰ Chronicle Keeper has successfully preserved the lore!"
            echo "ğŸ“œ New TLDL entry has been added to the eternal chronicle"
          fi
          
          if [[ "${{ steps.generate-daily-ledger.outputs.ledger-generated }}" == "true" || "${{ steps.scheduled-daily-ledger.outputs.scheduled-ledger-generated }}" == "true" ]]; then
            echo "ğŸ““ Daily Ledger entry has been created or updated"
            echo "ğŸ”— Navigation links have been updated to maintain the unbroken chain"
          fi
          
          # Faculty Standards Refactoring Summary
          if [[ "${{ steps.refactoring-analysis.outputs.analysis-available }}" == "true" ]]; then
            echo ""
            echo "ğŸ’¸ Faculty Standards Analysis:"
            echo "  Issues detected: ${{ steps.refactoring-analysis.outputs.issues-found }}"
            echo "  Refactoring cost: ${{ steps.refactoring-analysis.outputs.refactoring-cost }} XP"
            echo "  Auto-refactoring: ${{ steps.refactoring-analysis.outputs.affordable == 'true' && 'âœ… Affordable' || 'âŒ Strategic timing needed' }}"
            
            if [[ "${{ steps.refactoring-analysis.outputs.refactoring-comment-ready }}" == "true" ]]; then
              echo "ğŸ“‹ Refactoring recommendations available in artifacts"
            fi
            
            echo "ğŸ“– Learn more: docs/costly-automatic-refactoring.md"
          fi
          
          if [[ "${{ github.event_name }}" == "schedule" ]]; then
            echo "â° Scheduled daily ledger ritual completed successfully"
            echo "ğŸŒ… A fresh page awaits today's development adventures"
          fi
          
          echo "ğŸ§™â€â™‚ï¸ The adventure continues, and the stories live on..."
          
          # Add a quote for good measure
          if [[ -f src/ScrollQuoteEngine/quote_engine.py ]]; then
            echo ""
            echo "ğŸ“œ A parting quote from the Secret Art:"
            python3 src/ScrollQuoteEngine/quote_engine.py --context lore --format cli || true
          fi
