#!/usr/bin/env python3
"""
Living Dev Agent XP System - Team Leaderboards & Secret Achievement Engine
Jerry's vision for ultimate team gamification with dynamic content generation

Features:
- Team-wide collaborative achievements
- Weekly secret achievements generated by AI
- Contributor perks and special abilities
- Dynamic achievement encryption/revelation system
"""

import json
import datetime
import random
import hashlib
import secrets
from pathlib import Path
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass
from enum import Enum
import uuid
import base64

# Import existing XP system
try:
    from dev_experience import DeveloperExperienceManager, ContributionType, QualityLevel, Achievement
    from theme_engine import GenreThemeManager, DeveloperGenre
    XP_SYSTEM_AVAILABLE = True
except ImportError:
    XP_SYSTEM_AVAILABLE = False

class AchievementRarity(Enum):
    """Achievement rarity levels"""
    COMMON = "common"           # 60% drop rate
    UNCOMMON = "uncommon"       # 25% drop rate  
    RARE = "rare"              # 10% drop rate
    EPIC = "epic"              # 4% drop rate
    LEGENDARY = "legendary"     # 1% drop rate
    MYTHICAL = "mythical"       # 0.1% drop rate (team-wide only)

class ContributorPerkType(Enum):
    """Types of perks contributors can earn"""
    ENHANCED_RESPONSES = "enhanced_responses"    # Copilot gives more detailed answers
    SECRET_KNOWLEDGE = "secret_knowledge"       # Access to hidden project insights
    TIME_DILATION = "time_dilation"            # XP multiplier for limited time
    ORACLE_MODE = "oracle_mode"                # Copilot becomes more creative/helpful
    LEGENDARY_STATUS = "legendary_status"       # Special signature on all contributions
    TEAM_BOOST = "team_boost"                  # Boosts entire team's XP for period

@dataclass
class ContributorPerk:
    """Special abilities and bonuses for contributors"""
    perk_id: str
    perk_type: ContributorPerkType
    name: str
    description: str
    duration_hours: int
    xp_multiplier: float = 1.0
    response_enhancement: str = ""
    special_signature: str = ""
    team_wide: bool = False
    expires_at: datetime.datetime = None
    
    def is_active(self) -> bool:
        """Check if perk is still active"""
        if self.expires_at is None:
            return True
        return datetime.datetime.now() < self.expires_at
    
    def activate(self) -> bool:
        """Activate the perk with expiration time"""
        if self.duration_hours > 0:
            self.expires_at = datetime.datetime.now() + datetime.timedelta(hours=self.duration_hours)
        return True

@dataclass
class SecretAchievement:
    """Dynamically generated secret achievements"""
    achievement_id: str
    name: str
    description: str
    hint: str
    condition: Dict[str, Any]
    rarity: AchievementRarity
    reward_perk: Optional[ContributorPerk]
    created_date: datetime.datetime
    expires_date: Optional[datetime.datetime]
    discovered_by: List[str] = None
    encrypted_details: str = ""
    
    def __post_init__(self):
        if self.discovered_by is None:
            self.discovered_by = []

@dataclass
class TeamAchievement:
    """Collaborative team-wide achievements"""
    achievement_id: str
    name: str
    description: str
    requirement: Dict[str, Any]
    contributors: List[str] = None
    progress: Dict[str, int] = None
    completed: bool = False
    completion_date: Optional[datetime.datetime] = None
    team_reward: Optional[ContributorPerk] = None
    
    def __post_init__(self):
        if self.contributors is None:
            self.contributors = []
        if self.progress is None:
            self.progress = {}

class TeamGameificationEngine:
    """Advanced team gamification with secret achievements and perks"""
    
    def __init__(self, workspace_path: str = "."):
        self.workspace_path = Path(workspace_path)
        
        # Initialize base XP system
        if XP_SYSTEM_AVAILABLE:
            self.xp_manager = DeveloperExperienceManager(workspace_path)
            self.theme_manager = GenreThemeManager(workspace_path)
        
        # Team gamification directories
        self.team_dir = self.workspace_path / "experience" / "team"
        self.team_dir.mkdir(parents=True, exist_ok=True)
        
        self.secrets_dir = self.team_dir / "secrets"
        self.secrets_dir.mkdir(exist_ok=True)
        
        # Data files
        self.team_achievements_file = self.team_dir / "team_achievements.json"
        self.secret_achievements_file = self.secrets_dir / "secret_achievements.json"
        self.contributor_perks_file = self.team_dir / "contributor_perks.json"
        self.team_leaderboard_file = self.team_dir / "team_leaderboard.json"
        
        # Load existing data
        self.team_achievements: List[TeamAchievement] = []
        self.secret_achievements: List[SecretAchievement] = []
        self.contributor_perks: Dict[str, List[ContributorPerk]] = {}
        
        self.load_team_data()

    def generate_weekly_secret_achievements(self) -> List[SecretAchievement]:
        """Generate weekly secret achievements using AI-inspired patterns"""
        
        # Secret achievement templates (Copilot-inspired)
        secret_templates = [
            {
                "name_pattern": "Code {adjective} {noun}",
                "hint_pattern": "Something {mysterious} happens when you {action}...",
                "conditions": ["commit_pattern", "file_pattern", "time_pattern", "collaboration_pattern"]
            },
            {
                "name_pattern": "The {mystical} {entity}",
                "hint_pattern": "Legend speaks of {entity} who {achievement}...",
                "conditions": ["consecutive_days", "quality_streak", "debugging_mastery"]
            },
            {
                "name_pattern": "{theme} {achievement_type} Master",
                "hint_pattern": "Only those who truly understand {theme} can unlock this...",
                "conditions": ["theme_consistency", "contribution_type", "team_synergy"]
            }
        ]
        
        # Dynamic word pools (theme-aware)
        adjectives = ["Ancient", "Hidden", "Mysterious", "Legendary", "Forbidden", "Sacred", "Ethereal"]
        nouns = ["Codex", "Cipher", "Artifact", "Rune", "Oracle", "Sentinel", "Keeper"]
        entities = ["Guardian", "Sage", "Architect", "Weaver", "Chronicler", "Artificer"]
        actions = ["commit at midnight", "solve 3 issues in one day", "help a teammate", "write epic documentation"]
        
        current_week = datetime.datetime.now().isocalendar()[1]
        random.seed(f"week_{current_week}")  # Deterministic but weekly-changing
        
        secrets = []
        
        # Generate 3-5 secret achievements per week
        for i in range(random.randint(3, 5)):
            template = random.choice(secret_templates)
            rarity = self._determine_secret_rarity()
            
            # Generate achievement details
            name = template["name_pattern"].format(
                adjective=random.choice(adjectives),
                noun=random.choice(nouns),
                mystical=random.choice(adjectives),
                entity=random.choice(entities),
                theme=self._get_current_theme_name(),
                achievement_type=random.choice(["Code", "Debug", "Collaboration"])
            )
            
            hint = template["hint_pattern"].format(
                mysterious=random.choice(["magical", "unexpected", "extraordinary"]),
                action=random.choice(actions),
                entity=random.choice(entities).lower(),
                achievement=random.choice(["masters the ancient arts", "transcends mortal limits", "unlocks hidden wisdom"]),
                theme=self._get_current_theme_name().lower()
            )
            
            # Create condition based on template
            condition = self._generate_secret_condition(random.choice(template["conditions"]))
            
            # Generate reward perk
            reward_perk = self._generate_secret_perk(rarity)
            
            secret = SecretAchievement(
                achievement_id=f"secret_{current_week}_{i}",
                name=name,
                description=f"A secret achievement that can only be unlocked by those who {hint.lower()}",
                hint=hint,
                condition=condition,
                rarity=rarity,
                reward_perk=reward_perk,
                created_date=datetime.datetime.now(),
                expires_date=datetime.datetime.now() + datetime.timedelta(days=7),
                encrypted_details=self._encrypt_achievement_details(name, condition)
            )
            
            secrets.append(secret)
        
        return secrets

    def _determine_secret_rarity(self) -> AchievementRarity:
        """Determine rarity using weighted random selection"""
        roll = random.random()
        
        if roll < 0.001:  # 0.1%
            return AchievementRarity.MYTHICAL
        elif roll < 0.01:  # 1%
            return AchievementRarity.LEGENDARY
        elif roll < 0.05:  # 4%
            return AchievementRarity.EPIC
        elif roll < 0.15:  # 10%
            return AchievementRarity.RARE
        elif roll < 0.40:  # 25%
            return AchievementRarity.UNCOMMON
        else:  # 60%
            return AchievementRarity.COMMON

    def _get_current_theme_name(self) -> str:
        """Get current theme name for context-aware achievements"""
        if hasattr(self, 'theme_manager') and self.theme_manager:
            return self.theme_manager.get_current_theme().name.split()[0]
        return "Mystical"

    def _generate_secret_condition(self, condition_type: str) -> Dict[str, Any]:
        """Generate specific conditions for secret achievements"""
        conditions = {
            "commit_pattern": {
                "type": "commit_analysis",
                "requires": {
                    "commit_time_hour": random.choice([0, 12, 23]),  # Midnight, noon, or late night
                    "message_contains": random.choice(["epic", "legendary", "magic", "secret", "hidden"]),
                    "files_changed": random.randint(3, 7)
                }
            },
            "consecutive_days": {
                "type": "activity_streak",
                "requires": {
                    "consecutive_contribution_days": random.randint(5, 10),
                    "min_xp_per_day": random.randint(100, 300)
                }
            },
            "quality_streak": {
                "type": "quality_consistency",
                "requires": {
                    "consecutive_epic_or_legendary": random.randint(3, 5),
                    "contribution_types": random.choice([["debugging_session"], ["innovation"], ["architecture"]])
                }
            },
            "collaboration_pattern": {
                "type": "team_synergy",
                "requires": {
                    "help_teammates": random.randint(2, 4),
                    "shared_achievements": 1,
                    "time_window_hours": 24
                }
            },
            "debugging_mastery": {
                "type": "fuck_moment_mastery",
                "requires": {
                    "fuck_moments_resolved": random.randint(5, 10),
                    "resolution_speed": "under_2_hours",
                    "help_others_debug": random.randint(1, 3)
                }
            }
        }
        
        return conditions.get(condition_type, conditions["commit_pattern"])

    def _generate_secret_perk(self, rarity: AchievementRarity) -> ContributorPerk:
        """Generate reward perks based on achievement rarity"""
        
        perk_pools = {
            AchievementRarity.COMMON: [
                ContributorPerk(
                    perk_id=f"perk_{uuid.uuid4().hex[:8]}",
                    perk_type=ContributorPerkType.ENHANCED_RESPONSES,
                    name="Copilot's Favor",
                    description="Copilot provides more detailed and helpful responses for 24 hours",
                    duration_hours=24,
                    response_enhancement="detailed_explanations"
                )
            ],
            AchievementRarity.RARE: [
                ContributorPerk(
                    perk_id=f"perk_{uuid.uuid4().hex[:8]}",
                    perk_type=ContributorPerkType.TIME_DILATION,
                    name="XP Acceleration Field",
                    description="2x XP multiplier for 48 hours",
                    duration_hours=48,
                    xp_multiplier=2.0
                )
            ],
            AchievementRarity.LEGENDARY: [
                ContributorPerk(
                    perk_id=f"perk_{uuid.uuid4().hex[:8]}",
                    perk_type=ContributorPerkType.ORACLE_MODE,
                    name="Oracle's Wisdom",
                    description="Copilot becomes extraordinarily creative and insightful for 72 hours",
                    duration_hours=72,
                    response_enhancement="oracle_mode",
                    special_signature="ğŸ”® Oracle-Enhanced Response"
                )
            ],
            AchievementRarity.MYTHICAL: [
                ContributorPerk(
                    perk_id=f"perk_{uuid.uuid4().hex[:8]}",
                    perk_type=ContributorPerkType.TEAM_BOOST,
                    name="Team Mythical Blessing",
                    description="Entire team gets 1.5x XP for one week",
                    duration_hours=168,  # One week
                    xp_multiplier=1.5,
                    team_wide=True,
                    special_signature="âš¡ Mythical Team Blessing Active"
                )
            ]
        }
        
        # Default to common if rarity not found
        perks = perk_pools.get(rarity, perk_pools[AchievementRarity.COMMON])
        return random.choice(perks)

    def _encrypt_achievement_details(self, name: str, condition: Dict[str, Any]) -> str:
        """Create encrypted achievement details (can be revealed later)"""
        details = {
            "name": name,
            "condition": condition,
            "timestamp": datetime.datetime.now().isoformat()
        }
        
        # Simple encryption using base64 + rotation (not secure, just obfuscated)
        json_str = json.dumps(details)
        encoded = base64.b64encode(json_str.encode()).decode()
        
        # Rotate characters for additional obfuscation
        rotation = len(name) % 26
        rotated = ''.join(chr((ord(c) + rotation) % 256) if c.isalnum() else c for c in encoded)
        
        return rotated

    def check_secret_achievement_unlocks(self, developer_name: str) -> List[SecretAchievement]:
        """Check if developer has unlocked any secret achievements"""
        if not XP_SYSTEM_AVAILABLE:
            return []
        
        profile = self.xp_manager.get_developer_profile(developer_name)
        if not profile:
            return []
        
        unlocked = []
        
        for secret in self.secret_achievements:
            if developer_name in secret.discovered_by:
                continue  # Already unlocked
            
            if self._check_secret_condition(profile, secret.condition):
                secret.discovered_by.append(developer_name)
                unlocked.append(secret)
                
                # Award the perk
                if secret.reward_perk:
                    self.award_contributor_perk(developer_name, secret.reward_perk)
                
                print(f"ğŸ‰ SECRET ACHIEVEMENT UNLOCKED! ğŸ‰")
                print(f"   {secret.name}")
                print(f"   {secret.description}")
                print(f"   Rarity: {secret.rarity.value.upper()}")
                if secret.reward_perk:
                    print(f"   ğŸ Reward: {secret.reward_perk.name}")
        
        if unlocked:
            self.save_team_data()
        
        return unlocked

    def _check_secret_condition(self, profile, condition: Dict[str, Any]) -> bool:
        """Check if a secret achievement condition is met"""
        condition_type = condition.get("type", "unknown")
        requires = condition.get("requires", {})
        
        if condition_type == "commit_analysis":
            # Check recent commits for specific patterns
            recent_contributions = [c for c in profile.contributions 
                                 if (datetime.datetime.now() - c.timestamp).days <= 1]
            
            for contrib in recent_contributions:
                commit_hour = contrib.timestamp.hour
                if commit_hour == requires.get("commit_time_hour"):
                    message_keyword = requires.get("message_contains", "").lower()
                    if message_keyword in contrib.description.lower():
                        if len(contrib.files_affected) >= requires.get("files_changed", 0):
                            return True
        
        elif condition_type == "quality_streak":
            # Check for consecutive high-quality contributions
            required_streak = requires.get("consecutive_epic_or_legendary", 3)
            high_quality_count = 0
            
            for contrib in reversed(profile.contributions[-required_streak*2:]):
                if contrib.quality_level.value in ["epic", "legendary"]:
                    high_quality_count += 1
                    if high_quality_count >= required_streak:
                        return True
                else:
                    high_quality_count = 0
        
        elif condition_type == "fuck_moment_mastery":
            # Check FUCK moment resolution skills
            total_resolved = sum(contrib.metrics.get("fuck_moments_resolved", 0) 
                               for contrib in profile.contributions)
            return total_resolved >= requires.get("fuck_moments_resolved", 5)
        
        return False

    def award_contributor_perk(self, developer_name: str, perk: ContributorPerk) -> bool:
        """Award a special perk to a contributor"""
        if developer_name not in self.contributor_perks:
            self.contributor_perks[developer_name] = []
        
        # Activate the perk
        perk.activate()
        self.contributor_perks[developer_name].append(perk)
        
        print(f"ğŸ PERK AWARDED: {perk.name}")
        print(f"   {perk.description}")
        if perk.duration_hours > 0:
            print(f"   â° Duration: {perk.duration_hours} hours")
        
        return True

    def get_active_perks(self, developer_name: str) -> List[ContributorPerk]:
        """Get all active perks for a developer"""
        if developer_name not in self.contributor_perks:
            return []
        
        # Filter to only active perks
        active_perks = [perk for perk in self.contributor_perks[developer_name] if perk.is_active()]
        
        # Update the stored list to remove expired perks
        self.contributor_perks[developer_name] = active_perks
        
        return active_perks

    def create_team_achievement(self, name: str, description: str, requirement: Dict[str, Any]) -> TeamAchievement:
        """Create a new team-wide collaborative achievement"""
        achievement = TeamAchievement(
            achievement_id=f"team_{uuid.uuid4().hex[:8]}",
            name=name,
            description=description,
            requirement=requirement
        )
        
        self.team_achievements.append(achievement)
        return achievement

    def generate_team_leaderboard(self) -> Dict[str, Any]:
        """Generate comprehensive team leaderboard with multiple categories"""
        if not XP_SYSTEM_AVAILABLE:
            return {}
        
        leaderboard = {
            "generated_at": datetime.datetime.now().isoformat(),
            "categories": {}
        }
        
        # Overall XP leaderboard
        overall = self.xp_manager.get_leaderboard(limit=20)
        leaderboard["categories"]["overall_xp"] = [
            {
                "rank": i + 1,
                "developer": profile.developer_name,
                "total_xp": profile.total_xp,
                "level": profile.level,
                "title": profile.title,
                "achievements": len(profile.achievements),
                "active_perks": len(self.get_active_perks(profile.developer_name))
            }
            for i, profile in enumerate(overall)
        ]
        
        # This week's contributors
        week_start = datetime.datetime.now() - datetime.timedelta(days=7)
        weekly_contributors = []
        
        for profile in self.xp_manager.developer_profiles.values():
            week_contributions = [c for c in profile.contributions if c.timestamp >= week_start]
            if week_contributions:
                week_xp = sum(c.total_xp for c in week_contributions)
                weekly_contributors.append({
                    "developer": profile.developer_name,
                    "week_xp": week_xp,
                    "contributions": len(week_contributions),
                    "best_quality": max((c.quality_level.value for c in week_contributions), default="none")
                })
        
        weekly_contributors.sort(key=lambda x: x["week_xp"], reverse=True)
        leaderboard["categories"]["weekly_heroes"] = weekly_contributors[:10]
        
        # Secret achievement discoverers
        secret_discoverers = {}
        for secret in self.secret_achievements:
            for discoverer in secret.discovered_by:
                if discoverer not in secret_discoverers:
                    secret_discoverers[discoverer] = []
                secret_discoverers[discoverer].append(secret.rarity.value)
        
        leaderboard["categories"]["secret_masters"] = [
            {
                "developer": dev,
                "secrets_found": len(rarities),
                "rarest_secret": max(rarities) if rarities else "none"
            }
            for dev, rarities in secret_discoverers.items()
        ]
        
        return leaderboard

    def save_team_data(self) -> bool:
        """Save all team gamification data"""
        try:
            # Save team achievements
            team_data = {
                "version": "1.0",
                "last_updated": datetime.datetime.now().isoformat(),
                "achievements": [
                    {
                        "achievement_id": ta.achievement_id,
                        "name": ta.name,
                        "description": ta.description,
                        "requirement": ta.requirement,
                        "contributors": ta.contributors,
                        "progress": ta.progress,
                        "completed": ta.completed,
                        "completion_date": ta.completion_date.isoformat() if ta.completion_date else None
                    }
                    for ta in self.team_achievements
                ]
            }
            
            with open(self.team_achievements_file, 'w', encoding='utf-8') as f:
                json.dump(team_data, f, indent=2)
            
            # Save secret achievements
            secrets_data = {
                "version": "1.0",
                "last_updated": datetime.datetime.now().isoformat(),
                "secrets": [
                    {
                        "achievement_id": sa.achievement_id,
                        "name": sa.name,
                        "description": sa.description,
                        "hint": sa.hint,
                        "condition": sa.condition,
                        "rarity": sa.rarity.value,
                        "created_date": sa.created_date.isoformat(),
                        "expires_date": sa.expires_date.isoformat() if sa.expires_date else None,
                        "discovered_by": sa.discovered_by,
                        "encrypted_details": sa.encrypted_details
                    }
                    for sa in self.secret_achievements
                ]
            }
            
            with open(self.secret_achievements_file, 'w', encoding='utf-8') as f:
                json.dump(secrets_data, f, indent=2)
            
            # Save contributor perks
            perks_data = {
                "version": "1.0",
                "last_updated": datetime.datetime.now().isoformat(),
                "perks": {
                    dev: [
                        {
                            "perk_id": perk.perk_id,
                            "perk_type": perk.perk_type.value,
                            "name": perk.name,
                            "description": perk.description,
                            "duration_hours": perk.duration_hours,
                            "xp_multiplier": perk.xp_multiplier,
                            "response_enhancement": perk.response_enhancement,
                            "special_signature": perk.special_signature,
                            "team_wide": perk.team_wide,
                            "expires_at": perk.expires_at.isoformat() if perk.expires_at else None
                        }
                        for perk in perks
                    ]
                    for dev, perks in self.contributor_perks.items()
                }
            }
            
            with open(self.contributor_perks_file, 'w', encoding='utf-8') as f:
                json.dump(perks_data, f, indent=2)
            
            return True
            
        except Exception as e:
            print(f"âŒ Failed to save team data: {e}")
            return False

    def load_team_data(self) -> bool:
        """Load all team gamification data"""
        try:
            # Load team achievements
            if self.team_achievements_file.exists():
                with open(self.team_achievements_file, 'r', encoding='utf-8') as f:
                    team_data = json.load(f)
                
                for ta_data in team_data.get("achievements", []):
                    self.team_achievements.append(TeamAchievement(
                        achievement_id=ta_data["achievement_id"],
                        name=ta_data["name"],
                        description=ta_data["description"],
                        requirement=ta_data["requirement"],
                        contributors=ta_data.get("contributors", []),
                        progress=ta_data.get("progress", {}),
                        completed=ta_data.get("completed", False),
                        completion_date=datetime.datetime.fromisoformat(ta_data["completion_date"]) if ta_data.get("completion_date") else None
                    ))
            
            # Load secret achievements
            if self.secret_achievements_file.exists():
                with open(self.secret_achievements_file, 'r', encoding='utf-8') as f:
                    secrets_data = json.load(f)
                
                for sa_data in secrets_data.get("secrets", []):
                    self.secret_achievements.append(SecretAchievement(
                        achievement_id=sa_data["achievement_id"],
                        name=sa_data["name"],
                        description=sa_data["description"],
                        hint=sa_data["hint"],
                        condition=sa_data["condition"],
                        rarity=AchievementRarity(sa_data["rarity"]),
                        reward_perk=None,  # Will be reconstructed if needed
                        created_date=datetime.datetime.fromisoformat(sa_data["created_date"]),
                        expires_date=datetime.datetime.fromisoformat(sa_data["expires_date"]) if sa_data.get("expires_date") else None,
                        discovered_by=sa_data.get("discovered_by", []),
                        encrypted_details=sa_data.get("encrypted_details", "")
                    ))
            
            # Load contributor perks
            if self.contributor_perks_file.exists():
                with open(self.contributor_perks_file, 'r', encoding='utf-8') as f:
                    perks_data = json.load(f)
                
                for dev, perk_list in perks_data.get("perks", {}).items():
                    self.contributor_perks[dev] = []
                    for perk_data in perk_list:
                        perk = ContributorPerk(
                            perk_id=perk_data["perk_id"],
                            perk_type=ContributorPerkType(perk_data["perk_type"]),
                            name=perk_data["name"],
                            description=perk_data["description"],
                            duration_hours=perk_data["duration_hours"],
                            xp_multiplier=perk_data.get("xp_multiplier", 1.0),
                            response_enhancement=perk_data.get("response_enhancement", ""),
                            special_signature=perk_data.get("special_signature", ""),
                            team_wide=perk_data.get("team_wide", False),
                            expires_at=datetime.datetime.fromisoformat(perk_data["expires_at"]) if perk_data.get("expires_at") else None
                        )
                        self.contributor_perks[dev].append(perk)
            
            return True
            
        except Exception as e:
            print(f"âš ï¸ Could not load team data: {e}")
            return False


def main():
    """Team Gamification CLI"""
    import argparse
    
    parser = argparse.ArgumentParser(description="ğŸ® Team Gamification & Secret Achievement Engine")
    parser.add_argument('--workspace', default='.', help='Workspace directory path')
    parser.add_argument('--generate-secrets', action='store_true', help='Generate weekly secret achievements')
    parser.add_argument('--check-secrets', help='Check secret achievements for developer')
    parser.add_argument('--leaderboard', action='store_true', help='Show team leaderboard')
    parser.add_argument('--perks', help='Show active perks for developer')
    parser.add_argument('--create-team-achievement', nargs=3, metavar=('NAME', 'DESCRIPTION', 'REQUIREMENT_JSON'),
                       help='Create team achievement')
    
    args = parser.parse_args()
    
    try:
        engine = TeamGameificationEngine(workspace_path=args.workspace)
        
        if args.generate_secrets:
            secrets = engine.generate_weekly_secret_achievements()
            engine.secret_achievements.extend(secrets)
            engine.save_team_data()
            
            print(f"ğŸ² Generated {len(secrets)} secret achievements for this week:")
            for secret in secrets:
                print(f"   ğŸ­ {secret.name} ({secret.rarity.value})")
                print(f"      Hint: {secret.hint}")
                print()
        
        elif args.check_secrets:
            unlocked = engine.check_secret_achievement_unlocks(args.check_secrets)
            if not unlocked:
                print(f"ğŸ” No new secret achievements unlocked for {args.check_secrets}")
        
        elif args.leaderboard:
            leaderboard = engine.generate_team_leaderboard()
            
            print("ğŸ† TEAM LEADERBOARD ğŸ†")
            print("=" * 50)
            
            # Overall XP leaders
            if "overall_xp" in leaderboard.get("categories", {}):
                print("\nğŸ‘‘ Overall XP Leaders:")
                for entry in leaderboard["categories"]["overall_xp"][:5]:
                    perks_indicator = f" (+{entry['active_perks']} perks)" if entry['active_perks'] > 0 else ""
                    print(f"  {entry['rank']}. {entry['developer']} - {entry['total_xp']} XP ({entry['title']}){perks_indicator}")
            
            # Weekly heroes
            if "weekly_heroes" in leaderboard.get("categories", {}):
                print("\nâš¡ This Week's Heroes:")
                for entry in leaderboard["categories"]["weekly_heroes"][:5]:
                    print(f"  ğŸ”¥ {entry['developer']} - {entry['week_xp']} XP ({entry['contributions']} contributions)")
            
            # Secret masters
            if "secret_masters" in leaderboard.get("categories", {}):
                print("\nğŸ­ Secret Achievement Masters:")
                for entry in leaderboard["categories"]["secret_masters"][:5]:
                    print(f"  ğŸ•µï¸ {entry['developer']} - {entry['secrets_found']} secrets found")
        
        elif args.perks:
            perks = engine.get_active_perks(args.perks)
            if perks:
                print(f"ğŸ Active Perks for {args.perks}:")
                for perk in perks:
                    time_left = ""
                    if perk.expires_at:
                        remaining = perk.expires_at - datetime.datetime.now()
                        hours_left = int(remaining.total_seconds() / 3600)
                        time_left = f" ({hours_left}h remaining)"
                    
                    print(f"  âœ¨ {perk.name}{time_left}")
                    print(f"     {perk.description}")
                    if perk.xp_multiplier > 1.0:
                        print(f"     ğŸš€ {perk.xp_multiplier}x XP multiplier")
                    print()
            else:
                print(f"ğŸ“­ No active perks for {args.perks}")
        
        elif args.create_team_achievement:
            name, description, requirement_json = args.create_team_achievement
            try:
                requirement = json.loads(requirement_json)
                achievement = engine.create_team_achievement(name, description, requirement)
                engine.save_team_data()
                print(f"ğŸ† Created team achievement: {achievement.name}")
            except json.JSONDecodeError:
                print("âŒ Invalid JSON for requirement")
        
        else:
            print("ğŸ® Team Gamification Engine")
            print("Use --help to see available commands")
            
    except KeyboardInterrupt:
        print("\nâš ï¸ Team gamification interrupted")
    except Exception as e:
        print(f"âŒ Team gamification error: {e}")


if __name__ == "__main__":
    main()
