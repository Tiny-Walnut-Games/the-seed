#!/usr/bin/env node
/**
 * CID Schoolhouse - Post Comment
 * 
 * Posts the repository critique as a structured comment to the GitHub issue.
 * Formats findings, gaps, and proposals in a readable format with evidence links.
 */

const fs = require('fs');
const { execSync } = require('child_process');

class CommentPoster {
    constructor(githubToken) {
        this.githubToken = githubToken;
    }

    formatReport(report) {
        let comment = `## üéì CID Schoolhouse Report\n\n`;
        
        // Executive Summary
        comment += `### üìú Executive TLDL\n\n`;
        if (report.summary && report.summary.length > 0) {
            report.summary.forEach(point => {
                comment += `- ${point}\n`;
            });
        } else {
            comment += `- Repository analysis complete\n`;
            comment += `- Found ${report.stats.findings} noteworthy findings\n`;
            comment += `- Identified ${report.stats.gaps} improvement opportunities\n`;
            comment += `- Generated ${report.stats.proposals} enhancement proposals\n`;
        }
        comment += `\n`;

        // Findings
        if (report.findings && report.findings.length > 0) {
            comment += `### üîç Findings (Evidence-Linked)\n\n`;
            
            const categories = [...new Set(report.findings.map(f => f.category))];
            categories.forEach(category => {
                const categoryFindings = report.findings.filter(f => f.category === category);
                comment += `#### ${this.categoryIcon(category)} ${this.capitalizeCategory(category)}\n\n`;
                
                categoryFindings.forEach(finding => {
                    comment += `**${finding.title}** (${finding.impact} impact)  \n`;
                    comment += `${finding.description}  \n`;
                    if (finding.evidence) {
                        comment += `üìÑ *Evidence: ${finding.evidence}*\n\n`;
                    } else {
                        comment += `\n`;
                    }
                });
            });
        }

        // Gaps and Risks
        if (report.gaps && report.gaps.length > 0) {
            comment += `### ‚ö†Ô∏è Critique (Gaps & Risks)\n\n`;
            
            const riskCategories = [...new Set(report.gaps.map(g => g.category))];
            riskCategories.forEach(category => {
                const categoryGaps = report.gaps.filter(g => g.category === category);
                comment += `#### ${this.categoryIcon(category)} ${this.capitalizeCategory(category)}\n\n`;
                
                categoryGaps.forEach(gap => {
                    comment += `**${gap.title}** (${gap.risk} risk)  \n`;
                    comment += `${gap.description}  \n`;
                    if (gap.files && gap.files.length > 0) {
                        comment += `üìÅ *Suggested files: ${gap.files.join(', ')}*\n\n`;
                    } else {
                        comment += `\n`;
                    }
                });
            });
        }

        // Proposals  
        if (report.proposals && report.proposals.length > 0) {
            comment += `### üí° Proposals (Effort/Impact)\n\n`;
            
            const proposalCategories = [...new Set(report.proposals.map(p => p.category))];
            proposalCategories.forEach(category => {
                const categoryProposals = report.proposals.filter(p => p.category === category);
                comment += `#### ${this.categoryIcon(category)} ${this.capitalizeCategory(category)}\n\n`;
                
                categoryProposals.slice(0, 3).forEach(proposal => { // Limit to 3 per category
                    comment += `**${proposal.title}** (${proposal.effort} effort, ${proposal.impact} impact)  \n`;
                    comment += `${proposal.description}  \n`;
                    if (proposal.files && proposal.files.length > 0) {
                        comment += `üìÅ *Files: ${proposal.files.join(', ')}*\n\n`;
                    } else {
                        comment += `\n`;
                    }
                });
            });
        }

        // CID Badges
        if (report.badges && report.badges.length > 0) {
            comment += `### üèÜ CID Badge Timeline\n\n`;
            report.badges.forEach(badge => {
                comment += `üéñÔ∏è ${badge}  \n`;
            });
            comment += `\n`;
        }

        // Footer
        comment += `---\n\n`;
        comment += `*Generated by CID Schoolhouse at ${new Date().toISOString()}*  \n`;
        comment += `*Repository analysis complete. Use comment triggers for additional actions:*\n`;
        comment += `- \`üìù add-issues\` to create GitHub issues from top proposals\n`;
        comment += `- \`TLDL: [summary]\` to add to living documentation\n`;

        return comment;
    }

    categoryIcon(category) {
        const icons = {
            'documentation': 'üìö',
            'automation': 'ü§ñ',
            'ci_cd': '‚öôÔ∏è',
            'security': 'üîí',
            'quality': '‚úÖ',
            'developer_experience': 'üë®‚Äçüíª',
            'process': 'üîÑ'
        };
        return icons[category] || 'üìã';
    }

    capitalizeCategory(category) {
        return category
            .split('_')
            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
            .join(' ');
    }

    async postComment(issueNumber, report) {
        if (!this.githubToken) {
            console.log('‚ÑπÔ∏è No GitHub token provided - outputting comment content:');
            console.log(this.formatReport(report));
            return;
        }

        const commentBody = this.formatReport(report);
        
        try {
            // Use GitHub CLI to post comment
            const tempFile = `/tmp/cid-comment-${Date.now()}.md`;
            fs.writeFileSync(tempFile, commentBody);
            
            execSync(`gh issue comment ${issueNumber} --body-file "${tempFile}"`, {
                env: { ...process.env, GITHUB_TOKEN: this.githubToken },
                stdio: 'inherit'
            });
            
            fs.unlinkSync(tempFile);
            console.log(`‚úÖ Comment posted to issue #${issueNumber}`);
            
        } catch (error) {
            console.error('‚ùå Failed to post comment:', error.message);
            console.log('üìÑ Comment content would have been:');
            console.log(commentBody);
        }
    }
}

// CLI interface
if (require.main === module) {
    const args = process.argv.slice(2);
    const issueNumber = args.find(arg => arg.startsWith('--issue='))?.split('=')[1];
    const reportFile = args.find(arg => arg.startsWith('--report='))?.split('=')[1] || 'out/cid/report.json';
    const githubToken = process.env.GITHUB_TOKEN;

    if (!issueNumber) {
        console.error('‚ùå Issue number required: --issue=123');
        process.exit(1);
    }

    try {
        const report = JSON.parse(fs.readFileSync(reportFile, 'utf8'));
        const poster = new CommentPoster(githubToken);
        poster.postComment(issueNumber, report);
    } catch (error) {
        console.error('‚ùå Failed to post comment:', error.message);
        process.exit(1);
    }
}

module.exports = CommentPoster;