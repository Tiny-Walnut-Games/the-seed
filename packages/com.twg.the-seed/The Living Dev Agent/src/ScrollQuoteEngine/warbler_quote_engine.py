#!/usr/bin/env python3
"""
ğŸŒŸ REVOLUTIONARY Warbler-Powered Scroll Quote Engine
The Living Quote Oracle - Dynamic wisdom generation for the Secret Art of the Living Dev

Combines static quotes from the Sacred Database with dynamic generation via Warbler templates,
creating fresh wisdom weekly while maintaining the mystical atmosphere of the Cheekdom.

Author: Bootstrap Sentinel & Living Dev Agent
Sacred Mission: Transform static scrolls into living oracles of development wisdom
"""

import os
import sys
import json
import yaml
import random
import subprocess
import argparse
import datetime
from pathlib import Path
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass

# Add project root to path for imports
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

@dataclass
class WisdomQuote:
    """A piece of sacred wisdom from the scrolls or oracle"""
    text: str
    author: str
    source: str
    volume: str = ""
    tags: List[str] = None
    buttsafe_certified: bool = True
    generated: bool = False  # True if generated by Warbler
    generation_date: str = ""
    template_id: str = ""

@dataclass
class WarblerSlotData:
    """Data for filling Warbler template slots"""
    development_actions = [
        "Refactoring", "Code review", "Testing", "Documentation", "Debugging",
        "Architecture design", "Feature implementation", "Bug fixing", "Optimization"
    ]
    
    misconceptions = [
        "admitting failure", "wasted time", "perfectionist paralysis", "unnecessary overhead",
        "busy work", "a sign of weakness", "avoiding real work", "procrastination"
    ]
    
    deeper_truths = [
        "evolution of understanding", "investment in clarity", "path to mastery",
        "foundation of reliability", "art of foresight", "discipline of craft",
        "wisdom accumulation", "legacy preservation"
    ]
    
    metaphors = [
        "pruning a garden", "sharpening a blade", "tuning an instrument", 
        "polishing a gem", "strengthening foundations", "clearing pathways",
        "weaving tapestries", "nurturing growth"
    ]
    
    domains = [
        "algorithms", "architecture", "documentation", "testing", "deployment",
        "maintenance", "collaboration", "problem-solving", "system design"
    ]
    
    author_titles = [
        "The Great Validator", "Code Whisperer", "Algorithm Sage", "Debug Oracle",
        "Architecture Mystic", "Documentation Prophet", "Refactoring Monk",
        "Test Guardian", "Deployment Shaman", "Merge Conflict Mediator"
    ]
    
    source_titles = [
        "Secret Art of the Living Dev", "Scrolls of Cheekdom", "Chronicles of Code Clarity",
        "Wisdom of the Terminal", "Mystical Methods of Development", "Sacred Scrolls",
        "Digital Development Sutras", "Codex of Comfortable Coding"
    ]
    
    volume_designations = [
        "Vol. I", "Vol. II", "Vol. III", "Vol. IV", "Vol. V",
        "Chapter 1, Verse 1", "Chapter 2, Verse 3", "Chapter 4, Verse 7",
        "Book of Beginnings", "Tome of Transformation", "Manuscript of Mastery"
    ]

class WarblerPoweredScrollEngine:
    """ğŸ­ The Living Oracle - Warbler-enhanced quote generation system"""
    
    def __init__(self, quotes_path: str = None):
        self.project_root = Path(__file__).parent.parent.parent  # Go up from src/ScrollQuoteEngine to project root
        self.quotes_path = quotes_path or self.project_root / "data" / "secret_art_quotes.yaml"
        self.warbler_pack_path = self.project_root / "packs" / "warbler-pack-wisdom-scrolls"
        self.generated_quotes_cache = self.project_root / "data" / "generated_wisdom_cache.json"
        
        # Load static quotes
        self.static_quotes = self._load_static_quotes()
        self.slot_data = WarblerSlotData()
        
        # Load or initialize generated quotes cache
        self.generated_quotes = self._load_generated_cache()
        
        # Warbler integration
        self.warbler_available = self._check_warbler_availability()
        
    def _load_static_quotes(self) -> Dict[str, List[WisdomQuote]]:
        """Load the sacred static quotes database"""
        try:
            with open(self.quotes_path, 'r', encoding='utf-8') as f:
                data = yaml.safe_load(f)
            
            quotes_by_category = {}
            for category, quote_list in data.get('quotes', {}).items():
                quotes_by_category[category] = []
                for quote_data in quote_list:
                    quote = WisdomQuote(
                        text=quote_data['text'],
                        author=quote_data['author'],
                        source=quote_data['source'],
                        volume=quote_data.get('volume', ''),
                        tags=quote_data.get('tags', []),
                        buttsafe_certified=quote_data.get('buttsafe_certified', True),
                        generated=False
                    )
                    quotes_by_category[category].append(quote)
            
            return quotes_by_category
            
        except Exception as e:
            print(f"âš ï¸ Failed to load static quotes: {e}")
            return {}
    
    def _load_generated_cache(self) -> List[WisdomQuote]:
        """Load previously generated quotes from cache"""
        try:
            if self.generated_quotes_cache.exists():
                with open(self.generated_quotes_cache, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                quotes = []
                for quote_data in data.get('quotes', []):
                    quote = WisdomQuote(
                        text=quote_data['text'],
                        author=quote_data['author'],
                        source=quote_data['source'],
                        volume=quote_data.get('volume', ''),
                        tags=quote_data.get('tags', []),
                        buttsafe_certified=quote_data.get('buttsafe_certified', True),
                        generated=True,
                        generation_date=quote_data.get('generation_date', ''),
                        template_id=quote_data.get('template_id', '')
                    )
                    quotes.append(quote)
                
                return quotes
        except Exception as e:
            print(f"âš ï¸ Failed to load generated cache: {e}")
        
        return []
    
    def _save_generated_cache(self):
        """Save generated quotes to cache"""
        try:
            cache_data = {
                'last_updated': datetime.datetime.utcnow().isoformat(),
                'quotes': []
            }
            
            for quote in self.generated_quotes:
                cache_data['quotes'].append({
                    'text': quote.text,
                    'author': quote.author,
                    'source': quote.source,
                    'volume': quote.volume,
                    'tags': quote.tags or [],
                    'buttsafe_certified': quote.buttsafe_certified,
                    'generation_date': quote.generation_date,
                    'template_id': quote.template_id
                })
            
            # Ensure data directory exists
            self.generated_quotes_cache.parent.mkdir(exist_ok=True)
            
            with open(self.generated_quotes_cache, 'w', encoding='utf-8') as f:
                json.dump(cache_data, f, indent=2, ensure_ascii=False)
                
        except Exception as e:
            print(f"âš ï¸ Failed to save generated cache: {e}")
    
    def _check_warbler_availability(self) -> bool:
        """Check if Warbler simulation is available"""
        try:
            simulate_script = self.project_root / "scripts" / "simulate-warble.mjs"
            return simulate_script.exists()
        except:
            return False
    
    def generate_weekly_wisdom(self, count: int = 5) -> List[WisdomQuote]:
        """ğŸ­ Generate fresh wisdom quotes using Warbler templates"""
        if not self.warbler_available:
            print("âš ï¸ Warbler not available, using static quotes only")
            return []
        
        generated_quotes = []
        
        try:
            # Load warbler templates
            templates = self._load_warbler_templates()
            if not templates:
                print("âš ï¸ No Warbler templates found")
                return []
            
            for i in range(count):
                template = random.choice(templates)
                quote = self._generate_quote_from_template(template)
                if quote:
                    generated_quotes.append(quote)
            
            # Add to cache and save
            self.generated_quotes.extend(generated_quotes)
            self._save_generated_cache()
            
            print(f"ğŸ­ Generated {len(generated_quotes)} new wisdom quotes")
            return generated_quotes
            
        except Exception as e:
            print(f"âŒ Failed to generate weekly wisdom: {e}")
            return []
    
    def _load_warbler_templates(self) -> List[Dict]:
        """Load Warbler wisdom generation templates"""
        try:
            templates_file = self.warbler_pack_path / "pack" / "templates.json"
            if not templates_file.exists():
                print(f"âš ï¸ Warbler templates not found at {templates_file}")
                return []
            
            with open(templates_file, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            return data.get('templates', [])
            
        except Exception as e:
            print(f"âŒ Failed to load Warbler templates: {e}")
            return []
    
    def _generate_quote_from_template(self, template: Dict) -> Optional[WisdomQuote]:
        """Generate a quote using a specific Warbler template"""
        try:
            template_id = template.get('id', 'unknown')
            content = template.get('content', '')
            required_slots = template.get('requiredSlots', [])
            
            # Fill template slots
            filled_content = content
            for slot in required_slots:
                slot_name = slot['name']
                slot_value = self._get_slot_value(slot_name)
                filled_content = filled_content.replace(f"{{{{{slot_name}}}}}", slot_value)
            
            # Generate attribution if needed
            if template_id == 'wisdom_development_insight':
                attribution = self._generate_attribution()
                return WisdomQuote(
                    text=filled_content,
                    author=attribution['author'],
                    source=attribution['source'],
                    volume=attribution['volume'],
                    tags=template.get('tags', []),
                    buttsafe_certified=True,
                    generated=True,
                    generation_date=datetime.datetime.utcnow().isoformat(),
                    template_id=template_id
                )
            else:
                # For other templates, use simpler approach
                return WisdomQuote(
                    text=filled_content,
                    author="Oracle of Generated Wisdom",
                    source="Living Scroll Synthesis",
                    volume="Generated Series I",
                    tags=template.get('tags', []),
                    buttsafe_certified=True,
                    generated=True,
                    generation_date=datetime.datetime.utcnow().isoformat(),
                    template_id=template_id
                )
                
        except Exception as e:
            print(f"âŒ Failed to generate quote from template {template.get('id', 'unknown')}: {e}")
            return None
    
    def _get_slot_value(self, slot_name: str) -> str:
        """Get a random value for a template slot"""
        slot_mappings = {
            'action': self.slot_data.development_actions,
            'misconception': self.slot_data.misconceptions,
            'deeper_truth': self.slot_data.deeper_truths,
            'metaphor': self.slot_data.metaphors,
            'domain': self.slot_data.domains,
            'author_title': self.slot_data.author_titles,
            'source_title': self.slot_data.source_titles,
            'volume_designation': self.slot_data.volume_designations,
            'problem_type': ['bug', 'memory leak', 'race condition', 'null pointer', 'infinite loop'],
            'action_verb': ['reproduce', 'capture', 'isolate', 'debug', 'trace'],
            'creature': ['monster', 'shadow', 'whisper', 'phantom', 'specter'],
            'location': ['bed', 'staircase', 'closet', 'attic', 'basement'],
            'reality_statement': ['real, but only when no one\'s looking', 'there, but only during production'],
            'what_its_not': ['what you write for others', 'a necessary evil', 'waste of time'],
            'what_it_really_is': ['what you write for the you of six months from now', 'a love letter to future maintainers'],
            'realm': ['kingdom', 'sacred lands', 'digital territories', 'mystical realm'],
            'guardian_class': ['Buttwarden', 'Code Guardian', 'Comfort Sentinel', 'Debug Paladin'],
            'civilization': ['comfortable development', 'ergonomic harmony', 'peaceful coding'],
            'threat_type': ['runtime catastrophe', 'documentation destruction', 'comfort corruption'],
            'body_part': ['posterior', 'back', 'wrists', 'neck', 'shoulders'],
            'sacred_designation': ['sacred', 'a temple of productivity', 'precious', 'holy'],
            'protection_action': ['Protect it', 'Honor it', 'Preserve it', 'Cherish it'],
            'protection_means': ['ergonomic wisdom', 'proper equipment', 'mindful practices', 'sacred tools']
        }
        
        options = slot_mappings.get(slot_name, [f"[{slot_name}]"])
        return random.choice(options)
    
    def _generate_attribution(self) -> Dict[str, str]:
        """Generate mystical attribution for quotes"""
        return {
            'author': random.choice(self.slot_data.author_titles),
            'source': random.choice(self.slot_data.source_titles),
            'volume': random.choice(self.slot_data.volume_designations)
        }
    
    def get_quote(self, category: str = None, context: str = None, 
                  include_generated: bool = True) -> WisdomQuote:
        """Get a quote (static or generated) based on criteria"""
        
        # Combine static and generated quotes
        all_quotes = []
        
        # Add static quotes
        if category and category in self.static_quotes:
            all_quotes.extend(self.static_quotes[category])
        elif not category:
            for cat_quotes in self.static_quotes.values():
                all_quotes.extend(cat_quotes)
        
        # Add generated quotes if enabled
        if include_generated:
            if category:
                # Filter generated quotes by category/tags
                generated_filtered = [q for q in self.generated_quotes 
                                    if category in (q.tags or [])]
                all_quotes.extend(generated_filtered)
            else:
                all_quotes.extend(self.generated_quotes)
        
        if not all_quotes:
            # Fallback quote
            return WisdomQuote(
                text="When the scroll database fails, improvisation becomes the highest art.",
                author="Emergency Protocols",
                source="Disaster Recovery Scrolls",
                volume="Vol. 404",
                buttsafe_certified=True
            )
        
        return random.choice(all_quotes)
    
    def get_quote_for_context(self, context: str) -> WisdomQuote:
        """Get contextually appropriate quote"""
        context_mappings = {
            'readme': ['general', 'documentation'],
            'tldl': ['documentation', 'workflow'],
            'ci': ['ci_cd', 'development'],
            'debug': ['debugging', 'development'],
            'development': ['development', 'general'],
            'documentation': ['documentation', 'general'],
            'workflow': ['workflow', 'general'],
            'commit': ['commits', 'development'],
            'buttsafe': ['buttsafe', 'general']
        }
        
        categories = context_mappings.get(context.lower(), ['general'])
        
        # Try each category until we find quotes
        for category in categories:
            quote = self.get_quote(category=category)
            if quote:
                return quote
        
        # Final fallback
        return self.get_quote()
    
    def format_quote(self, quote: WisdomQuote, format_type: str = 'cli') -> str:
        """Format quote for different output types"""
        
        if format_type == 'markdown':
            generated_indicator = " âœ¨" if quote.generated else ""
            volume_text = f", {quote.volume}" if quote.volume else ""
            return f"> *\"{quote.text}\"* â€” **{quote.author}**{generated_indicator}, {quote.source}{volume_text}"
        
        elif format_type == 'plain':
            return f'"{quote.text}" â€” {quote.author}, {quote.source}'
        
        else:  # cli format
            generated_indicator = " âœ¨" if quote.generated else ""
            volume_text = f", {quote.volume}" if quote.volume else ""
            return f"ğŸ“œ From the Secret Art of the Living Dev:\nğŸª¶ \"{quote.text}\"\n   â€” {quote.author}{generated_indicator}, {quote.source}{volume_text}"
    
    def show_statistics(self) -> Dict[str, Any]:
        """Show quote database statistics"""
        static_count = sum(len(quotes) for quotes in self.static_quotes.values())
        generated_count = len(self.generated_quotes)
        
        stats = {
            'static_quotes': static_count,
            'generated_quotes': generated_count,
            'total_quotes': static_count + generated_count,
            'categories': len(self.static_quotes),
            'warbler_available': self.warbler_available,
            'last_generation': self.generated_quotes[-1].generation_date if self.generated_quotes else None
        }
        
        return stats

def main():
    """CLI interface for the Warbler-Powered Scroll Engine"""
    parser = argparse.ArgumentParser(description="ğŸ­ Warbler-Powered Scroll Quote Engine")
    parser.add_argument('--category', help='Quote category to select from')
    parser.add_argument('--context', help='Context hint for appropriate quote selection')
    parser.add_argument('--format', choices=['cli', 'markdown', 'plain'], 
                       default='cli', help='Output format')
    parser.add_argument('--generate', type=int, metavar='COUNT',
                       help='Generate COUNT new quotes using Warbler')
    parser.add_argument('--stats', action='store_true', 
                       help='Show database statistics')
    parser.add_argument('--no-generated', action='store_true',
                       help='Exclude generated quotes from selection')
    parser.add_argument('--quotes-path', help='Path to custom quotes database')
    
    args = parser.parse_args()
    
    # Initialize engine
    engine = WarblerPoweredScrollEngine(args.quotes_path)
    
    if args.generate:
        # Generate new quotes
        print(f"ğŸ­ Generating {args.generate} new wisdom quotes...")
        new_quotes = engine.generate_weekly_wisdom(args.generate)
        
        if new_quotes:
            print(f"\nâœ¨ Generated {len(new_quotes)} new quotes:")
            for i, quote in enumerate(new_quotes, 1):
                print(f"\n{i}. {engine.format_quote(quote, 'cli')}")
        else:
            print("âŒ Failed to generate new quotes")
        
        return
    
    if args.stats:
        # Show statistics
        stats = engine.show_statistics()
        print("ğŸ“Š Warbler-Powered Scroll Engine Statistics:")
        print(f"   ğŸ“š Static quotes: {stats['static_quotes']}")
        print(f"   âœ¨ Generated quotes: {stats['generated_quotes']}")
        print(f"   ğŸ“– Total quotes: {stats['total_quotes']}")
        print(f"   ğŸ·ï¸  Categories: {stats['categories']}")
        print(f"   ğŸ­ Warbler available: {'âœ…' if stats['warbler_available'] else 'âŒ'}")
        if stats['last_generation']:
            print(f"   â° Last generation: {stats['last_generation']}")
        return
    
    # Get and display quote
    include_generated = not args.no_generated
    
    if args.context:
        quote = engine.get_quote_for_context(args.context)
    else:
        quote = engine.get_quote(category=args.category, include_generated=include_generated)
    
    print(engine.format_quote(quote, args.format))

if __name__ == '__main__':
    main()
