#!/usr/bin/env python3
"""
Alchemist Scaffold (v0.1.0)

Generates an experiment manifest from Gu Pot narrative inputs.

Usage:
  python scripts/alchemist_scaffold.py --issue 123 \
      --logline "Adaptive allocator reduces fragmentation" \
      --tension "Need lower p95 alloc latency without GC spikes" \
      --metric avg_frame_time_ms:reduce:ms:2 \
      --metric alloc_latency_p95:reduce:ms:2 \
      --engine-version 2025.1.0f1 \
      --output experiments/gu_pot/issue-123/manifest_v1.json

Metric format: name:direction:unit:precision
Directions: reduce | improve | increase | stabilize
"""
from __future__ import annotations
import argparse, hashlib, json, os, pathlib, re, sys, textwrap
from datetime import datetime, timezone

ALCHEMIST_VERSION = "0.1.0"

def normalize_text(s: str) -> str:
    return re.sub(r"\s+", " ", s.strip().lower())

def sha256_prefixed(s: str) -> str:
    return "sha256:" + hashlib.sha256(s.encode("utf-8")).hexdigest()

def parse_metric(raw: str):
    parts = raw.split(":")
    if len(parts) != 4:
        raise ValueError(f"Metric spec '{raw}' must be name:direction:unit:precision")
    name, direction, unit, precision = parts
    if direction not in {"reduce", "improve", "increase", "stabilize"}:
        raise ValueError(f"Unsupported direction '{direction}'")
    try:
        precision_i = int(precision)
    except ValueError:
        raise ValueError(f"Precision must be int in '{raw}'")
    return {
        "name": name,
        "unit": unit,
        "direction": direction,
        "precision": precision_i
    }

def build_manifest(args):
    now = datetime.now(timezone.utc).isoformat()
    logline_norm = normalize_text(args.logline)
    tension_norm = normalize_text(args.tension)
    manifest = {
        "schema_version": "0.1.0",
        "kind": "experiment_manifest",
        "generated_on": now,
        "alchemist_version": ALCHEMIST_VERSION,
        "origin": {
            "type": "gu_pot",
            "issue_number": args.issue,
            "issue_url": args.issue_url or f"https://github.com/OWNER/REPO/issues/{args.issue}"
        },
        "logline": args.logline,
        "tension": args.tension,
        "hashes": {
            "logline_hash": sha256_prefixed(logline_norm),
            "tension_hash": sha256_prefixed(tension_norm)
        },
        "hypothesis": args.hypothesis or "Because <mechanism>, we expect <metric> to <direction> by <range>.",
        "metrics": [parse_metric(m) for m in args.metric],
        "determinism": {
            "seed": args.seed,
            "platform": args.platform,
            "engine_version": args.engine_version
        },
        "execution": {
            "runner": "alchemist_runner_v1",
            "iterations": args.iterations
        },
        "thresholds": {
            "placeholder": "Define success/regression thresholds in validation phase."
        },
        "notes": "Generated by alchemist_scaffold.py"
    }
    return manifest

def main():
    p = argparse.ArgumentParser(description="Generate an Alchemist experiment manifest.")
    p.add_argument("--issue", type=int, required=True)
    p.add_argument("--issue-url", type=str)
    p.add_argument("--logline", required=True)
    p.add_argument("--tension", required=True)
    p.add_argument("--hypothesis", required=False)
    p.add_argument("--metric", action="append", required=True,
                   help="Metric spec: name:direction:unit:precision (repeatable)")
    p.add_argument("--seed", type=int, default=1337)
    p.add_argument("--platform", default="win64")
    p.add_argument("--engine-version", default="2025.1.0f1")
    p.add_argument("--iterations", type=int, default=1)
    p.add_argument("--output", required=True)
    args = p.parse_args()

    manifest = build_manifest(args)
    out_path = pathlib.Path(args.output)
    out_path.parent.mkdir(parents=True, exist_ok=True)
    with open(out_path, "w", encoding="utf-8") as f:
        json.dump(manifest, f, indent=2, sort_keys=False)
    print(f"[alchemist] wrote manifest -> {out_path}")

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print(f"[alchemist][error] {e}", file=sys.stderr)
        sys.exit(1)