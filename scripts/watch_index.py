import argparse
import os
import queue
import sys
import time
from pathlib import Path

try:
    from watchdog.observers import Observer
    from watchdog.events import FileSystemEventHandler
except Exception as e:
    print("[watch_index] Missing dependency: watchdog. Install with: pip install watchdog", file=sys.stderr)
    raise

# Directories that are auto-generated by Unity/Roslyn/IDEs and should be excluded
IGNORE_DIRS = {
    '.git',
    '.svn',
    '.hg',
    '.idea',
    '.vs',
    '.cache',
    'Library',          # Unity generated
    'Temp',             # Unity generated
    'obj',              # Roslyn build output
    'bin',              # Build output
    'node_modules',
}

# File patterns/extensions often not useful for text indexing
BINARY_EXTS = {
    '.dll', '.exe', '.png', '.jpg', '.jpeg', '.gif', '.bmp', '.ico', '.pdf', '.zip', '.7z', '.rar',
    '.mp3', '.mp4', '.wav', '.ogg', '.mov', '.avi', '.flac', '.unitypackage', '.asset', '.prefab',
    '.bundle', '.aac', '.ttf', '.otf', '.woff', '.woff2', '.psd', '.tga', '.dds', '.hdr', '.fbx',
}

# Max size to index directly (text). Large files may be skipped or handled differently by ingester
MAX_SIZE = 5 * 1024 * 1024  # 5 MB
DEBOUNCE_SEC = 1.0

class Handler(FileSystemEventHandler):
    def __init__(self, q, root: Path):
        self.q = q
        self.root = root

    def _should_ignore(self, path: Path) -> bool:
        parts = set(p.name for p in path.parents)
        if any(d in IGNORE_DIRS for d in parts):
            return True
        if path.suffix.lower() in BINARY_EXTS:
            return True
        try:
            if path.exists() and path.is_file() and path.stat().st_size > MAX_SIZE:
                # Allow logs to exceed MAX_SIZE if they are in Logs/ explicitly
                if 'Logs' in (p.name for p in path.parents):
                    return False
                return True
        except OSError:
            return False
        return False

    def on_any_event(self, event):
        if event.is_directory:
            return
        p = Path(event.src_path)
        # For renames, also consider dest_path if available
        if hasattr(event, 'dest_path') and event.dest_path:
            p = Path(event.dest_path)
        # Normalize to absolute
        p = p.resolve()
        # Only consider files under root
        try:
            p.relative_to(self.root)
        except Exception:
            return
        if not self._should_ignore(p):
            self.q.put((time.time(), str(p)))


def drain_and_dedupe(q: "queue.Queue[tuple[float,str]]"):
    pending = {}
    t0 = time.time()
    while True:
        try:
            t, p = q.get(timeout=DEBOUNCE_SEC)
            pending[p] = t
            if time.time() - t0 >= DEBOUNCE_SEC:
                break
        except queue.Empty:
            break
    return list(pending.keys())


def main():
    ap = argparse.ArgumentParser(description="Watch repo and trigger AI index updates on change")
    ap.add_argument('--path', default='.', help='Path to watch (repo root)')
    ap.add_argument('--cmd', default='python scripts/ingest.py --paths', help='Ingester command prefix')
    ap.add_argument('--debounce', type=float, default=DEBOUNCE_SEC, help='Debounce seconds')
    args = ap.parse_args()

    global DEBOUNCE_SEC
    DEBOUNCE_SEC = max(0.1, args.debounce)

    root = Path(args.path).resolve()
    q: "queue.Queue[tuple[float,str]]" = queue.Queue()

    obs = Observer()
    obs.schedule(Handler(q, root), str(root), recursive=True)
    obs.start()
    print(f"[watch_index] Watching {root}. Ctrl+C to stop.")

    try:
        while True:
            time.sleep(0.25)
            paths = drain_and_dedupe(q)
            if not paths:
                continue
            joined = ' '.join(f'"{p}"' for p in paths)
            cmd = f"{args.cmd} {joined}"
            print('[watch_index] >', cmd)
            rc = os.system(cmd)
            if rc != 0:
                print(f"[watch_index] Ingester exited with code {rc}", file=sys.stderr)
    except KeyboardInterrupt:
        pass
    finally:
        obs.stop()
        obs.join()


if __name__ == '__main__':
    main()
